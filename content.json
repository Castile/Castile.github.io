{"meta":{"title":"Castile","subtitle":"","description":"","author":"朱宏梁","url":"https://Castile.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-01-17T12:20:33.000Z","updated":"2020-02-11T03:29:15.718Z","comments":true,"path":"categories/index.html","permalink":"https://castile.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-02-11T05:16:11.000Z","updated":"2020-02-11T05:16:11.975Z","comments":true,"path":"about/index.html","permalink":"https://castile.github.io/about/index.html","excerpt":"","text":""},{"title":"link","date":"2020-02-11T05:09:54.000Z","updated":"2020-02-11T05:10:20.885Z","comments":true,"path":"link/index.html","permalink":"https://castile.github.io/link/index.html","excerpt":"","text":""},{"title":"music","date":"2020-02-11T05:15:57.000Z","updated":"2020-02-11T09:38:19.444Z","comments":true,"path":"music/index.html","permalink":"https://castile.github.io/music/index.html","excerpt":"","text":"我的音乐 一首歌，一个故事。 var ap = new APlayer({ element: document.getElementById(\"aplayer-xVYqLxaM\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-02-11T03:27:47.000Z","updated":"2020-02-11T03:28:43.489Z","comments":true,"path":"tags/index.html","permalink":"https://castile.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中的Pair","slug":"Java中的Pair","date":"2020-02-12T04:52:45.000Z","updated":"2020-02-12T05:06:16.133Z","comments":true,"path":"2020/02/12/Java中的Pair/","link":"","permalink":"https://castile.github.io/2020/02/12/Java%E4%B8%AD%E7%9A%84Pair/","excerpt":"","text":"Java 中的Pair ​ Pair（配对）： 当一个函数返回两个值并且两个值都有重要意义时我们一般会用Map的key和value来表达，但是这样的话就需要两个键值对，用Map映射去做处理时，此时的key相当于value的一个描述或者引用，而具体的信息都保存在value中，我们可以通过key去获取对应的value。但是当key和value都保存具体信息时，我们就需要用到Pair对了。Pair对也是键值对的形式。 ​ 实际上Pair保存的应该说是一个信息对，两个信息都是我们需要的，没有key和value之分。 实现 ​ 在javax.util包下，有一个简单Pair类可以直接调用，用法是直接通过构造函数将所吸引类型的Key和value存入，这个key和value没有任何的对应关系类型。 java123456789101112131415161718import javafx.util.Pair;/** * @author Hongliang Zhu * @create 2020-02-12 13:02 */public class pair &#123; public static void main(String[] args) &#123; Pair&lt;Integer, String&gt; p = new Pair&lt;&gt;(1, \"zhuhongliang\"); // 要传入对应的值 System.out.println(p.getKey()); System.out.println(p.getValue()); Pair&lt;String, String&gt; p2 = new Pair&lt;&gt;(\"Tony\", \"Jane\"); System.out.println(p2.getKey()); System.out.println(p2.getValue()); &#125;&#125; 1 zhuhongliang Tony Jane 这种Pair的返回对一个函数返回两个都有意义的值有特别用处。","categories":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/tags/Java/"}]},{"title":"leetcode-50-幂函数","slug":"leetcode-50-幂函数","date":"2020-02-12T04:29:27.000Z","updated":"2020-02-12T09:02:10.317Z","comments":true,"path":"2020/02/12/leetcode-50-幂函数/","link":"","permalink":"https://castile.github.io/2020/02/12/leetcode-50-%E5%B9%82%E5%87%BD%E6%95%B0/","excerpt":"","text":"描述 leetcode-50 Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 链接：https://leetcode-cn.com/problems/powx-n 分析 暴力求解： 这个会超时，这里要处理一下n小于0的情况， 当n小于0的时候，将x变成1/x， n = -n； 快速幂： https://blog.csdn.net/qq_19782019/article/details/85621386 ​ 快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。 代码 https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode50_pow.java java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package RecurrenceAndDynamicProgramming;/** * @author Hongliang Zhu * @create 2020-02-12 15:39 */public class leetcode50_pow &#123; public static double pow(double x, int n) &#123; long N = n; if (n &lt; 0) &#123; N = -N; x = 1 / x; &#125; double ans = 1.0; for (int i = 0; i &lt; N; i++) &#123; ans *= x; ans %= 1000; &#125; return ans; &#125; /** * 快速幂 * @param x 底数 * @param n 指数 * @return 结果 求最后三位数 */ public static double fast_pow(double x, int n)&#123; double result = 1; while (n &gt; 0 )&#123;// if(n % 2 == 0)&#123;// // 如果指数为偶数// n /= 2;// x = x * x % 1000;// &#125;if(n % 2 != 0 )&#123;// // 指数为奇数// n--; // 指数减一为偶数// result = result * x % 1000;// n /= 2;// x = x * x % 1000;// &#125; if( (n &amp; 1) == 1) &#123; // n%2 == 1 奇数 使用位运算更加高效 result = result * x % 1000; &#125; // n /= 2; n &gt;&gt;= 2; // 右移 x = x * x % 1000; &#125; return result % 1000; &#125; public static void main(String[] args) &#123; long start = System.nanoTime();// double ans = pow(2, 1000000000); double anss = fast_pow(2, 10000000); long end = System.nanoTime(); System.out.println(anss); System.out.println(\"耗时：\" + (end - start) +\" ns\"); &#125;&#125; 附上AC的结果： java123456789101112131415161718192021222324class Solution &#123; public double myPow(double x, int n) &#123; long N = n; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; return fastPow(x, N); &#125; private double fastPow(double x, long n)&#123; if(n == 0) return 1.0; double ans = 1.0; while(n &gt; 0)&#123; if((n &amp; 1 ) == 1)&#123; ans = ans*x; &#125; n &gt;&gt;= 1; x = x * x; &#125; return ans; &#125;&#125;; 快速幂很巧妙！值得学习！加油！！！","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"数学","slug":"数学","permalink":"https://castile.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"leetcode-104-二叉树的最大深度","slug":"leetcode-104-二叉树的最大深度","date":"2020-02-12T04:29:06.000Z","updated":"2020-02-12T06:08:50.624Z","comments":true,"path":"2020/02/12/leetcode-104-二叉树的最大深度/","link":"","permalink":"https://castile.github.io/2020/02/12/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"描述 leetcode-104： 二叉树的最大深度【简单】 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 / 9 20 / 15 7 返回它的最大深度 3 。 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 分析 很直观想到递归来解决，根节点的数的高度等于 1 加上 左子树的高度与右子数高度的最大值。 Rooth=1+max⁡(SubL+SubR)Root_h = 1 + \\max(Sub_L + Sub_R) Rooth​=1+max(SubL​+SubR​) 迭代： BFS广度优先遍历，因为BFS是按层次遍历，所以二叉树有多少层，二叉树的高度就等于层数。 dfs： 其实是按照二叉树的前序遍历顺序，将每个节点的当前深度记录下来，这里使用了Pair结构 时间复杂度均为O(n)， 空间复杂度均为O(n)，如果是平衡二叉树的话，时间复杂度最好情况为O(logN)。 代码 github: https://github.com/Castile/algorithm/blob/master/leetcode/src/Tree/leetcode104_MaximumDepthofBinaryTree.java java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import com.sun.org.apache.xalan.internal.xsltc.util.IntegerArray;import javafx.util.Pair;import jdk.internal.org.objectweb.asm.commons.InstructionAdapter;import sun.awt.TracedEventQueue;import java.util.LinkedList;/** * @author Hongliang Zhu * @create 2020-02-06 22:38 */class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class leetcode104_MaximumDepthofBinaryTree &#123; // static int i =0;// static int j = 0; // 不能在这里定义 public static int maxDepth(TreeNode root) &#123; if (root == null) return 0; int i = maxDepth(root.left); int j = maxDepth(root.right); return Math.max(i, j) + 1; &#125; /** * BFS 层次遍历， 记录层数，即为深度 * * @param root 根节点 * @return 二叉树的深度 */ public static int maxDepth_BFS(TreeNode root) &#123; if (root == null) return 0; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 队列 queue.add(root); int maxDepth = 0; while (!queue.isEmpty()) &#123; maxDepth++;// 层数加1 // 将当前层出队列 int currSize = queue.size(); for (int i = 0; i &lt; currSize; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; &#125; return maxDepth; &#125; public static int maxDepth_DFS(TreeNode root) &#123; if (root == null) return 0; LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); // 栈 stack.push(new Pair&lt;&gt;(root, 1)); // 根节点的深度为1 int maxDepth = 0; while (!stack.isEmpty()) &#123; Pair&lt;TreeNode, Integer&gt; currNode = stack.pop(); // 当前节点 maxDepth = Math.max(maxDepth, currNode.getValue()); // 与当前节点的深度比较 // 左右子树进栈 if (currNode.getKey().left != null) &#123; stack.push(new Pair&lt;&gt;(currNode.getKey().left, currNode.getValue() + 1)); // 深度加1 &#125; if (currNode.getKey().right != null) &#123; stack.push(new Pair&lt;&gt;(currNode.getKey().right, currNode.getValue() + 1)); &#125; &#125; return maxDepth; &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode(1); TreeNode t2 = new TreeNode(2); TreeNode t3 = new TreeNode(3); TreeNode t4 = new TreeNode(4); TreeNode t5 = new TreeNode(5); root.left = t2; root.right = t3; t2.left = t4; t2.right = t5; System.out.println(maxDepth(root)); // 3 System.out.println(maxDepth_BFS(root)); // 3 System.out.println(maxDepth_DFS(root)); // 3 &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://castile.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"leetcode-206-反转链表","slug":"leetcode-206-反转链表","date":"2020-02-06T09:39:44.000Z","updated":"2020-02-06T10:06:18.234Z","comments":true,"path":"2020/02/06/leetcode-206-反转链表/","link":"","permalink":"https://castile.github.io/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"描述 leetcode206： 反转链表 【简单】 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 链接：https://leetcode-cn.com/problems/reverse-linked-list 分析 迭代： 如下图： ​ 时间复杂度：O(n) 。 假设 n 是列表的长度，时间复杂度是 O(n)。 ​ 空间复杂度：O(1)。 递归 1、找到递归出口 2、确定返回值 3、分析单次递归需要做的事情 下面，我们来具体分析一下： 首先，找到递归出口，这个还是非常简单的，就是当前即将反转的节点为 null 或者是 反转链表 为 null 时（一轮递归其实就只有两个节点，后面会讲），说明已经全部反转完毕了，即递归出口； 其次，确定返回值，我们只需要返回反转链表的头结点即可； 最后，分析单次递归需要做的事情，递归其实每一轮做的事情都是一样的，我们不需要去重复考虑，这样反而会很乱，只需要考虑单轮递归需要做什么就可以了。在这里，我们就只有两个节点，一个是即将反转的节点元素，一个是已经反转完毕的链表头结点。 我们要做的一轮递归只是 将当前节点加入到反转链表中，仅此而已。 链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/bang-zhu-da-jia-li-jie-di-gui-zuo-fa-by-jeromememo/ 代码 https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode206_ReverseLinkedList.java java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package LinkedList;/** * @author Hongliang Zhu * @create 2020-02-06 17:09 *//* 反转单链表： 要求时间复杂度为O((n) ，空间复杂度为O(1)； Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL */public class leetcode206_ReverseLinkedList &#123; // 迭代 public static ListNode reverseList(ListNode head) &#123; if(head == null) return head; ListNode pre = null; ListNode next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; // 递归版本 public static ListNode reverdeList_Recur(ListNode head)&#123; return help(head, null, head.next); &#125; public static ListNode help(ListNode head, ListNode pre, ListNode next)&#123; if(head == null) return pre; next = head.next; head.next = pre; pre = head; head = next; return help(head, pre, next); &#125; // 优美递归 public static ListNode reverseListRR(ListNode head)&#123; if(head == null || head.next == null) return head; ListNode p = reverseListRR(head.next); //这里的cur就是最后一个节点 ListNode cur = reverseList(head.next); //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5 //而head是4，head的下一个是5，下下一个是空 //所以head.next.next 就是5-&gt;4 head.next.next = head; //防止链表循环，需要将head.next设置为空 head.next = null; //每层递归函数都返回cur，也就是最后一个节点 return p; &#125; public static void printLinkedList(ListNode head)&#123; if(head == null) return; ListNode p = head; while (p != null)&#123; System.out.print(p.val +\"\\t\"); p = p.next; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; ListNode head = new ListNode(1); ListNode n1 = new ListNode(2); ListNode n2 = new ListNode(3); ListNode n3 = new ListNode(4); ListNode n4 = new ListNode(5); head.next = n1; n1.next = n2; n2.next = n3; n3.next = n4; printLinkedList(head); ListNode re = reverseListRR(head); printLinkedList(re); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"https://castile.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"leetcode-119-杨辉三角2","slug":"leetcode-119-杨辉三角2","date":"2020-02-06T07:28:31.000Z","updated":"2020-02-06T08:26:20.916Z","comments":true,"path":"2020/02/06/leetcode-119-杨辉三角2/","link":"","permalink":"https://castile.github.io/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/","excerpt":"","text":"描述 leetcode119： 杨辉三角2 【简单】 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: Code12输入: 3输出: [1,3,3,1] 分析 这题和前一题一样，只不过返回特定层，同样的思路 java123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); int[][] dp = new int[rowIndex+2][rowIndex+2]; if(rowIndex+1 == 0) return null; for(int i = 1 ; i &lt;= rowIndex+1; i++)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 1; j &lt;= i ; j++)&#123; list.add(calc(dp, i, j)); &#125; triangle.add(list); &#125; return triangle.get(rowIndex); // 注意返回的是指定层 &#125; public int calc(int[][] dp, int i, int j)&#123; if( j == 1 || i == j)&#123; dp[i][j] = 1; return 1; &#125; if(dp[i][j] != 0) return dp[i][j]; dp[i][j] = calc(dp, i - 1, j - 1) + calc(dp, i - 1, j); return dp[i][j]; &#125;&#125; 这题和杨辉三角1的题目差不多，118题需要保存所有的，但是这题只需要返回指定层，因为当前层的值只依赖于上一层的值，故使用一个list来保存上一层的值。 java12345678910111213141516public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; pre = new ArrayList&lt;&gt;(); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= rowIndex; i++)&#123; cur = new ArrayList&lt;&gt;(); for(int j = 0; j &lt;= i ; j++)&#123; if(j == 0 || i == j)&#123; cur.add(1); &#125;else&#123; cur.add(pre.get(j - 1) + pre.get(j)); &#125; &#125; pre = cur; &#125; return cur; &#125; 基于2可以继续优化：以把 pre 的 List 省去。这样的话，cur每次不去新建 List，而是把cur当作pre。 又因为更新当前 j 的时候，就把之前j的信息覆盖掉了。而更新 j + 1 的时候又需要之前j的信息，所以在更新前，我们需要一个变量把之前j的信息保存起来。 java1234567891011121314public List&lt;Integer&gt; getRow(int rowIndex) &#123; int pre = 1; List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); cur.add(1); // j == 0 for(int i = 1; i &lt;= rowIndex; i++)&#123; for(int j = 1; j &lt; i; j++)&#123; int tmp = cur.get(j); cur.set(j, pre + cur.get(j)); pre = tmp; &#125; cur.add(1); // j == i &#125; return cur; &#125; 除了上边优化的思路，还有一种想法，那就是倒着进行，这样就不会存在覆盖的情况了。因为更新完j的信息后，虽然把j之前的信息覆盖掉了。但是下一次我们更新的是j - 1，需要的是j - 1和j - 2 的信息，j信息覆盖就不会造成影响了。 代码 https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode119_PascalTriangle2.java 相似题目：杨辉三角","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"dp","slug":"dp","permalink":"https://castile.github.io/tags/dp/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"leetcode-118-杨辉三角1","slug":"leetcode-118-杨辉三角1","date":"2020-02-06T07:28:12.000Z","updated":"2020-02-12T04:33:54.279Z","comments":true,"path":"2020/02/06/leetcode-118-杨辉三角1/","link":"","permalink":"https://castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/","excerpt":"","text":"描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 链接：https://leetcode-cn.com/problems/pascals-triangle 分析 暴力递归：basecase：可以看到，每行的最左边和最右边的数字是1。因此，我们可以将基本情况定义如下: f(i, j)=1 where j=1 or j==i 递推关系： ​ 首先，我们定义一个函数 f(i,j)它将会返回帕斯卡三角形第 i 行、第 j 列的数字。 我们可以用下面的公式来表示这一递推关系：f(i,j)=f(i−1,j−1)+f(i−1,j) 动态规划：因为暴力递归还有很多值会重复计算，所以使用一个数组保存已经计算过的值。 代码 源码： https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode118_PascalTriangle.java java1234567891011121314151617// 暴力递归： 但是会超时 public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); if(numRows == 0) return triangle; for(int i = 1 ; i &lt;= numRows; i++)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 1; j &lt;= i ; j++)&#123; list.add(calc(i, j)); &#125; triangle.add(list); &#125; return triangle; &#125; public int calc(int i, int j)&#123; if( j == 1 || i == j) return 1; return calc(i - 1, j - 1) + calc(i - 1, j); &#125; 动态规划： java12345678910111213141516171819202122232425// 动态规划 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); int[][] dp = new int[numRows+1][numRows+1]; if(numRows == 0) return triangle; for(int i = 1 ; i &lt;= numRows; i++)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j = 1; j &lt;= i ; j++)&#123; list.add(calc(dp, i, j)); &#125; triangle.add(list); &#125; return triangle; &#125; public int calc(int[][] dp, int i, int j)&#123; if( j == 1 || i == j)&#123; dp[i][j] = 1; return 1; &#125; if(dp[i][j] != 0) return dp[i][j]; dp[i][j] = calc(dp, i - 1, j - 1) + calc(dp, i - 1, j); return dp[i][j]; &#125; &#125; 相似题目： leetcode-119-杨辉三角2","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"dp","slug":"dp","permalink":"https://castile.github.io/tags/dp/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"CosNet:基于协同注意孪生网络的无监督视频目标分割","slug":"CosNet-基于协同注意孪生网络的无监督视频目标分割","date":"2020-02-05T13:42:03.000Z","updated":"2020-02-12T04:33:02.825Z","comments":true,"path":"2020/02/05/CosNet-基于协同注意孪生网络的无监督视频目标分割/","link":"","permalink":"https://castile.github.io/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/","excerpt":"","text":"【CVPR2019】CosNet：See More, Know More: Unsupervised Video Object Segmentation with Co-Attention Siamese Networks 基于协同注意孪生网络的无监督视频目标分割 概述 ​ 以往的无监督视频目标分割基于深度学习的方法仅仅考虑短期时域信息，没有考虑整个视频的全局信息，而且并没有有效利用视频内容的内在相关信息 ，**Co-attention Siamese Network(CosNet)**提出了一个统一的端到端的无监督视频目标分割网络。 ​ CosNet将UVOS作为co-attention的过程。一个co-attention模块学习去显示编码帧与帧之间的关系，使CosNet可以获取频繁相关的区域，进而可以帮助发现前景目标来进行分割。具体的，在训练阶段，co-attention过程能够分解为同一视频中任意帧对之间的相关性学习，在测试的时候，CosNet使用全局视角推断前景目标，也就是说利用测试帧与多个相关的帧的co-attention信息来判断主要的前景目标。CosNet的网络结构如下图所示。这是无监督视频目标分割最好的模型，在Davis2016数据集上的J-means达到了80.5的分数。 ​ CosNet认为无监督视频目标分割下的主要目标拥有以下特点： 1)单帧可区分(本地显著性)； 2)在整个视频序列中频繁出现的目标(全局一致性)。 ​ 这两个特点对于区分视频序列中的主要目标的非常重要的。通过考虑视频的全局信息，可以锁定主要目标，进而进行分割。 网络结构 ​ 输入是图片对，图片对可以从视频中随机取得。两帧图片经过基网络（DeeplabV3），也称编码网络（Encoder）， 将两帧编码成嵌入特征，然后协同注意力模块会计算两帧的相似性，即两帧之间的相关注意力特征。最后输入到分割模块得到最后的分割结果。 算法 Co-attention Mechanisms in COSNet 作者提出了三种协同注意力机制，分别为Vanilla co-attention， Symmetric co-attention，Channel-wise co-attention。一个注意力模块这显式地编码两帧之间的相关性，这样可以使得COsNet学习到频繁相关的区域。 Vanilla co-attention S 是两帧之间的afﬁnity matrix（相似矩阵），Va和Vb的shape是 W∗H∗CW * H * C W∗H∗C Va的每一列表示特征向量，W是一个方阵 所以S又可以写成： 通过上面公式，首先对每一帧的特征表示进行线性变换，然后计算它们之间的距离 。 Symmetric co-attention 如果对权重矩阵进行约束，令权重矩阵为一个对称矩阵。则投影矩阵P就变成一个正交矩阵 I是一个C * C的单位阵。则Symmetric co-attention的计算公式为： 上述公式表明将嵌入向量Va和Vb的特征投影到正交公共空间中，并保持它们的范数。这一特性可以消除不同通道之间的相关性和提高网络的泛化能力。 Channel-wise co-attention 将投影矩阵P简单地表示成单位矩阵 I （也就是没有进行空间的转换），然后权重矩阵W变成对角矩阵，在这种情况下，W（也就是D）可以分为两个对角矩阵Da和Db， 因此，公式3可以重新写成一下形式，也就是Channel-wise co-attention： 这个操作相当于在计算相似度之前对Va和Vb应用一个信道权值, 这有助于缓解通道冗余 . 协同注意力操作 协同注意力操作如上图所示，在获取了相似度矩阵S之后，对S的行向量和列向量进行SoftMax操作： 结合上图： 在网络中的协同注意力模块还有一个Gated co-attention操作， 考虑到输入对、遮挡和背景噪声之间潜在的外观变化，最好对来自不同输入帧的信息进行加权，而不是平均处理所有的共同注意信息。 $$ \\sigma是一个sigmoid激活函数， w_f和b_f表示卷积核和偏置参数。 $$ 计算完gate的置信度之后，注意力Z表示为： CosNet 整体架构 CosNet是一个孪生网络，由三个级联的部分，一个基于DeepLabV3的特征嵌入模块，一个协同注意力模块以及分割模块。 训练阶段 ​ 上文说到，视频中的主要对象（即要分割的对象）有两个基本属性:(i)帧内可分辨性，(ii)帧间一致性。为了区分前景目标和背景(属性(i))，我们利用现有的显著性目标分割数据集DUTS和MSRA 10K来训练我们的backbone特征嵌入模块。同时，为了确保COSNet能够捕获主要视频对象的全局帧间相干性(property (ii))，我们使用视频分割数据训练整个COSNet，其中co-attention模块在捕获视频帧之间的相关性方面起着关键作用。具体来说，我们在一个视频序列中随机选取两帧来建立训练对。值得一提的是，与以往的基于循环神经网络的UVOS模型只需要连续帧相比，这种操作自然有效地扩充了训练数据, 即数据增强。 ​ 通过这种方式，COSNet可以交替使用静态图像数据和动态视频数据进行训练。在使用图像数据时，我们只训练了特征嵌入模块，其中增加了1×1的sigmoid激活卷积层，生成中间分割的sideoutput。视频数据用于训练整个COSNet，包括特征嵌入模块、协同注意模块和分割模块。利用加权二叉熵损失训练网络: 其实训练阶段是完全监督的，因为使用到了groundtruth。 测试阶段 ​ 训练完成之后，使用模型在其他没有见过的视频序列中进行测试。给定一个测试视频序列，我们可以将每个要分割的帧，以及从同一视频中采样的一个参考帧，依次输入到COSNet中，通过逐帧的操作，我们可以得到所有的分割结果。 ​ 然而，在这样一个简单的策略下，分割结果仍然含有相当大的噪声，因为视频中丰富的全局相关信息并没有得到充分的挖掘。因此，在测试阶段包含更多的是推导帧常重要的： 将一组N个不同的参考帧(从同一视频中均匀采样)输入推理分支，并对所有预测进行平均。 结果 DAVIS-2016数据集： FBMS数据集： YoutubeObjects 数据集： 结论 协同注意力机制基于全局的视角进行推断前景和背景的分割，效果显著。 在测试时，平均多个帧的的注意力更有效 为了研究最终预测在测试阶段的帧选择策略，我们进一步使用不同的采样方法进行了一系列的实验。具体采用全局随机抽样、全局均匀抽样和局部连续抽样。从表1中可以看出，两种全局水平的采样策略都能获得近似的性能，但都优于局部采样方法。同时，基于局部采样的结果仍然优于从骨干网获得的结果。整体比较进一步证明了合并的重要性 。 关于参考帧数的选择，如表： 当N = 0时，这意味着没有共同注意分割。当N从0变为1时，可以看到一个很大的性能改进 。N从2变化到5，定量结果显示性能有所提高。当我们进一步增加N时，最终的性能没有明显的变化。实验中使用的N=5。","categories":[{"name":"论文阅读","slug":"论文阅读","permalink":"https://castile.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"UVOS","slug":"UVOS","permalink":"https://castile.github.io/tags/UVOS/"},{"name":"papers","slug":"papers","permalink":"https://castile.github.io/tags/papers/"}]},{"title":"leetcode-344-反转字符串","slug":"leetcode-344-反转字符串","date":"2020-02-03T08:53:27.000Z","updated":"2020-02-03T09:10:10.508Z","comments":true,"path":"2020/02/03/leetcode-344-反转字符串/","link":"","permalink":"https://castile.github.io/2020/02/03/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"描述 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,“e”,“l”,“l”,“o”] 输出：[“o”,“l”,“l”,“e”,“h”] 示例 2： 输入：[“H”,“a”,“n”,“n”,“a”,“h”] 输出：[“h”,“a”,“n”,“n”,“a”,“H”] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 分析 就地操作，而且要是O(1)的空间，可以使用迭代方法，首尾指针解决 java1234567891011class Solution &#123; public void reverseString(char[] s) &#123; int len = s.length; char tmp; for(int i = 0; i &lt; len/2 ; i++)&#123; tmp = s[i]; s[i] = s[len - i - 1]; //这是末尾的值 s[len-i-1] = tmp; &#125; &#125;&#125; 也可以用递归来做，但是使用了辅助栈，不满足O(1)的空间要求 java1234567891011121314class Solution &#123; public void reverseString(char[] s) &#123; help(s, 0, s.length-1); &#125; private void help(char[] s, int i, int j) &#123; if (i &gt;= j) return; char tmp = s[i]; s[i] = s[j]; s[j] = tmp; i++; j--; help(s, i, j); &#125;&#125; 代码 https://github.com/Castile/algorithm/blob/master/leetcode/src/Str/leetcode344_ReverseStr.java","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"字符串","slug":"字符串","permalink":"https://castile.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"leetcode-24-两两交换链表中的节点","slug":"leetcode-24-两两交换链表中的节点","date":"2020-02-03T08:18:28.000Z","updated":"2020-02-03T08:51:25.948Z","comments":true,"path":"2020/02/03/leetcode-24-两两交换链表中的节点/","link":"","permalink":"https://castile.github.io/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例： 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs 分析 递归： ​ 我们可以定义函数 swap(head) 以实现解决方案，其中输入的参数 head 指向链表的头节点。* 而该函数应当返回将链表中每两个相邻节点交换后得到的新列表的头节点 head 。 ​ 按照我们上面列出的步骤，我们可以按下面的流程来实现函数： ​ （1）首先，我们交换列表中的前两个节点，也就是 head 和 head.next； ​ （2）然后我们以 swap(head.next.next) 的形式调用函数自身，以交换头两个节点之后列表的其余部分。 ​ （3）最后，我们将步骤（2）中的子列表的返回头与步骤（1）中交换的两个节点相连，以形成新的链 表。 迭代 新增一个头节点 dummy node， dummy.next = head； 更好操作链表。流程图如下： 代码 源码： https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode24_SwapNodesInPairs.java java123456789101112131415161718192021222324252627282930313233343536373839404142434445package LinkedList;/** * @author Hongliang Zhu * @create 2020-02-03 15:51 */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class leetcode24_SwapNodesInPairs &#123; // 递归解法 public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode n = head.next.next; // 下一次要传递的节点 //交换这两个节点 ListNode p = head.next; p.next = head; head.next = swapPairs(n); // 递归 return p; // 返回交换之后的头结点 &#125; // 迭代 public ListNode swapPairs_it(ListNode head) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; while(head != null &amp;&amp; head.next != null)&#123; ListNode first = head; ListNode second = head.next; // 交换 first.next = second.next; second.next = first; pre.next = second; // 初始化头 head = first.next; pre = first; &#125; return dummy.next; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"https://castile.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"链表","slug":"链表","permalink":"https://castile.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"leetcode-200-岛屿数量","slug":"leetcode-200-岛屿数量","date":"2020-02-02T09:50:20.000Z","updated":"2020-02-02T11:24:58.761Z","comments":true,"path":"2020/02/02/leetcode-200-岛屿数量/","link":"","permalink":"https://castile.github.io/2020/02/02/leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","excerpt":"","text":"描述 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 示例 2: 输入: 11000 11000 00100 00011 输出: 3 链接：https://leetcode-cn.com/problems/number-of-islands 分析 dfs： 深度优先搜索，很明显，这是一个连通问题，求出的连通分量的个数就是岛屿的数量 并查集： 这个是并查集的一个应用，求连通分量的个数。 bfs： 使用队列解决 这里有一个大佬的题解，非常详细： https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/ 官方题解也可。主要是理解算法思想 直接看代码吧 代码 并查集： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; int count = 0; public int numIslands(char[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; int[] parents = new int[n*m]; int[] rank = new int [n*m]; makeSet(grid, parents, rank); // 方向数组 d 是上下左右搜索的常用手法 int[][] d = new int[][]&#123;&#123;1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;; for(int i =0 ; i &lt; m; i++)&#123; for( int j = 0; j &lt; n; j++)&#123; if( grid[i][j] == '1')&#123; grid[i][j] = '0'; // 已经联合的点不需要连接了。 for(int k = 0; k &lt; 4; k++)&#123; int x = i + d[k][0]; int y = j + d[k][1]; if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1')&#123; unoin(parents, rank, x *n +y, i *n + j); &#125; &#125; &#125; &#125; &#125; return count; &#125; // 构建并查集的结构：注意这里的技巧 public void makeSet(char[][] grid, int []parents, int []rank)&#123; for(int i = 0; i &lt; grid.length ; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == '1')&#123; parents[i * grid[0].length + j] = i * grid[0].length + j; rank[i * grid[0].length + j] = 1; count++; // 连通分量 &#125;else&#123; parents[i * grid[0].length + j] = -1; rank[i * grid[0].length + j] = 0; &#125; &#125; &#125; &#125; public int find(int[] parents, int a)&#123; int root = parents[a]; while(root != parents[root])&#123; root = parents[root]; &#125; return root; &#125; public void unoin(int[] parents, int []rank, int a, int b)&#123; int ra = find(parents, a); int rb = find(parents, b); if(ra != rb)&#123; if(rank[ra] &gt; rank[rb])&#123; parents[rb] = ra; rank[ra] += rank[rb]; &#125;else&#123; parents[rb] = ra; rank[ra] += rank[rb]; &#125; count--; &#125;else &#123; return; &#125; &#125;&#125; dfs： java123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numIslands(char[][] grid) &#123; int cnt = 0; for(int i = 0; i &lt; grid.length; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == '1')&#123; cnt++; // 岛屿的个数加一 infect(grid, i, j, grid.length, grid[0].length); // 感染函数 &#125; &#125; &#125; return cnt; &#125; /** * 感染函数： 将i， j位置的上下左右位置进行检查，是否为同一个岛屿 * @param m： 岛屿矩阵 * @param i： 下标 * @param j： 下标 * @param R: 行 * @param C： 列 */ public static void infect(char[][] m, int i, int j, int R, int C)&#123; if(i &lt; 0 || i &gt;= R || j &lt; 0 || j &gt;= C || m[i][j] != '1') return; m[i][j] = '2'; // 依次感染上下左右位置 infect(m, i+1, j, R, C); infect(m, i-1, j, R, C); infect(m, i, j-1, R, C); infect(m, i, j+1, R, C); &#125;&#125; BFS： 使用队列 java12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; int m,n; int[][] d = new int[][]&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;, &#123;0,-1&#125;&#125;; // 广度优先遍历 public int numIslands(char[][] grid) &#123; if(grid == null || grid.length == 0) return 0; m = grid.length; n = grid[0].length; LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int count = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n ; j ++)&#123; if(grid[i][j] == '1')&#123; q.offer(i * n + j); // 入队 while(!q.isEmpty())&#123; int cur = q.poll(); // 出队 int cx = cur / n; int cy = cur % n; grid[cx][cy] = '0'; for(int[] dd: d)&#123; int x = cx + dd[0]; int y = cy + dd[1]; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == '1')&#123; q.offer(x * n + y); grid[x][y] = '0'; // 要标志已访问，不然会严重超时 &#125; &#125; &#125; count++; &#125; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"搜索","slug":"搜索","permalink":"https://castile.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"leetcode-695-岛屿的最大面积","slug":"leetcode-695-岛屿的最大面积","date":"2020-02-02T09:44:04.000Z","updated":"2020-02-02T09:49:39.394Z","comments":true,"path":"2020/02/02/leetcode-695-岛屿的最大面积/","link":"","permalink":"https://castile.github.io/2020/02/02/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"描述 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 链接：https://leetcode-cn.com/problems/max-area-of-island 分析 dfs： 岛屿问题，看到连通区域，想到dfs来做。 用DFS搜索每个value为1的位置，递归检查相邻的位置，如果访问过，则将value设为0（避免重复访问） 直接看代码注释 代码 java12345678910111213141516171819202122232425262728293031323334353637383940414243package search;/** * @author Hongliang Zhu * @create 2020-02-02 17:04 */public class leetcode_695_MaxAreaIsland &#123; int m; int n; int[][] d = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; public int maxAreaOfIsland(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; m = grid.length; n = grid[0].length; int result = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n ; j++)&#123; result = Math.max(result, dfs(grid, i, j)); //求最大的面积 &#125; &#125; return result; &#125;// int[][] d = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; public int dfs(int[][] grid, int x, int y)&#123; if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || grid[x][y] == 0)&#123; return 0; &#125; grid[x][y] = 0; int c = 1; // 面积加1 for(int k = 0; k &lt; 4; k++)&#123; // 注意使用不同的变量，如果使用x、y会报错 int i = x + d[k][0]; int j = y + d[k][1]; c += dfs(grid, i, j); // 搜索上下左右 &#125; // for(int[] dd: d)&#123; // c += dfs(grid, x + dd[0], y + dd[1]); // &#125; return c; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"搜索","slug":"搜索","permalink":"https://castile.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"leetcode-268-缺失的数字","slug":"leetcode-268-缺失的数字","date":"2020-02-02T02:54:27.000Z","updated":"2020-02-02T04:07:17.418Z","comments":true,"path":"2020/02/02/leetcode-268-缺失的数字/","link":"","permalink":"https://castile.github.io/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"[toc] 描述 给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1] 输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8 链接：https://leetcode-cn.com/problems/missing-number 分析 题目说从0~n的数字，所以直接累加数组得到和为sum， 加入数组没有缺失数据，那么完整数组的元素个数为原数组大小加1，利用等差数列的性质，得到从0~n的和len，然后len - sum 就是缺失的那个数字了。 时间复杂度：O(n)。求出数组中所有数的和的时间复杂度为 O(n)，等差数列公式的时间复杂度为 O(1)，因此总的时间复杂度为 O(n)。 空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。 位操作： 异或 a b 异或结果 0 0 0 0 1 1 1 0 1 1 1 0 其他数字 与 0 异或都得到它自己。 此外异或运算满足交换律. 如： 0 1 2 3 3 4 0 1 下标与数组值异或操作： 4 ^ 0 ^ 3 ^ 1 ^ 4 ^ 2 ^ 0 ^ 3 ^ 1 ( 前面的4是为了添加最后一位数字，为原数组的长度) ----&gt; 可得到缺失的值为2。 时间复杂度：O(n)。这里假设异或运算的时间复杂度是常数的，总共会进行O(n) 次异或运算，因此总的时间复杂度为 O(n)。 空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。 哈希表 将数组中的元素放入HashSet哈希表中， 插入哈希表的时间复杂度为O(1)， N个数时间复杂度为O(n)， 然后从0到数组放长度区间内遍历， 判断哈希表中是否存在此数字，若不存在， 则此数字就是缺失的数字。遍历时间复杂度为O(n)， 故总体时间复杂度为O(n)。空间复杂度为O(n)。 还可以先排序，再找出缺失的数字，但是排序的时间复杂度不是线性时间， 为O(logN) 代码 方法一： java123456789101112class Solution &#123; public int missingNumber(int[] nums) &#123; int sum = 0; for(int i = 0 ; i &lt; nums.length; i++)&#123; //数组的和 sum += nums[i]; &#125; // 缺失一个数字： 本来的和应该是： int len = (nums.length + 1) * nums.length / 2; return len - sum; &#125;&#125; 位操作： java123456789class Solution &#123; public int missingNumber(int[] nums) &#123; int m = nums.length; for(int i = 0; i &lt; nums.length; i++)&#123; m ^= i ^ nums[i]; &#125; return m; &#125;&#125; 哈希表： java12345678910111213141516class Solution &#123; public int missingNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for( int i = 0; i &lt;nums.length; i++)&#123; set.add(nums[i]); &#125; for(int i = 0 ; i &lt;= nums.length; i++)&#123; if( !set.contains(i)) return i; &#125; return -1; &#125; &#125; 排序： java12345678910111213141516171819class Solution &#123; public int missingNumber(int[] nums) &#123; Arrays.sort(nums); // 判断末尾 if(nums[nums.length - 1] != nums.length)&#123; return nums.length; &#125; // 判断0 是否在首位 if(nums[0] != 0)&#123; return 0; &#125; for( int i = 0; i &lt;nums.length ; i++)&#123; if(i != nums[i]) return i; &#125; return -1; &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"位操作","slug":"位操作","permalink":"https://castile.github.io/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"}]},{"title":"Java-集合框架","slug":"Java-集合框架","date":"2020-02-01T02:49:50.000Z","updated":"2020-02-11T12:33:05.083Z","comments":true,"path":"2020/02/01/Java-集合框架/","link":"","permalink":"https://castile.github.io/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"一、 概述 Collection ​ 集合是存储对象的容器，集合中可以存储任意类型的对象，而且长度可变。在程序中有可能无法预先知道需要多少个对象，那么用数组来装对象的话，长度不好定义，而集合解决了这样的问题。 ​ 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 注： 带对号的是线程安全类。 集合和数组的区别 数组和集合类都是容器 数组长度是固定的，集合长度是可变的。数组中可以存储基本数据类型，集合只能存储对象 数组中存储数据类型是单一的，集合中可以存储任意类型的对象。 集合类的特点：用于存储对象，长度是可变的，可以存储不同类型的对象。 从上图可以看到，Set、List、Queue都是继承Collection接口。（Map是接口，下面会详细描述） Set下面有HashSet、LinkedHashSet以及一个SortedSet接口，TreeSet继承SortedSet接口，说明TreeSet里面的元素一定是有序的。 List下面有ArrayList、Vector、 LinkedList Queue下面有LinkedList和PriorityQueue类(堆结构：优先级队列)，说明LinkedLIst可以当做队列来使用。 1. Set：唯一性 TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。红黑树的算法规则是左小右大。 红黑树是一种特定类型的二叉树， 是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： ​ 性质1：每个节点要么是黑色，要么是红色。 ​ 性质2：根节点是黑色。 ​ 性质3：每个叶子节点（NIL）是黑色。 ​ 性质4：每个红色结点的两个子结点一定都是黑色。 ​ 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。 红黑树以后会补上，详解见： 30张图带你彻底理解红黑树 TreeSet可以自然排序，那么TreeSet必定具有排序规则的 ​ ① 元素自身具有比较性，需要实现Comparable接口，重写compareTo方法。这种方式叫做元素的自然排序 ​ ② 容器具备比较性，当元素不具备比较性，或者自身具备的比较性不是所需要的，那么此时也可以让容器自身具备。需要定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。（注： 当Comparable比较方式和Comparator比较方式同时存在，以Comparator为主） ​ ③ 基本数据类型具备自身比较性，比如String， int等，String内部已经继承了Comparable接口，所以具备比较性，我们自己定义的元素，想要存入TreeSet中，就必须自己实现该接口，也就是说要让对象具备就比较性，如果存入相同的元素则只会存入一个到TreeSet中。 ​ ④ TreeSet中如何保证元素的唯一性： 通过compareTo或者compare方法来保证元素的唯一性。 Person类中有name和age属性，下面是重写的compareTo方法以及hashCode和equals方法。这是使元素自身具备比较性： java1234567891011121314151617181920212223242526 @Override public int hashCode() &#123; return nama.hashCode() + age*33; &#125; @Override public boolean equals(Object obj) &#123; if(!(obj instanceof Person))&#123; return false; &#125; Person p = (Person)obj; return this.nama.equals(p.nama) &amp;&amp; this.age == p.age; &#125; @Override public int compareTo(Object o) &#123; Person p = (Person)o; if(this.age &gt; p.age)&#123; return 1; &#125; if(this.age &lt; p.age)&#123; return -1; &#125; return this.nama.compareTo(p.nama); &#125; 下面是是使容器自身具备比较性，要自定义比较器：定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。 java123456789101112131415161718192021222324252627282930313233343536373839class MyComparator implements Comparator&#123; @Override public int compare(Object o1, Object o2) &#123; Person p1 = (Person) o1; Person p2 = (Person) o2; // 首先比较年龄，年龄不一样就是不同元素，因为存在同名的人 if(p1.getAge() &gt; p2.getAge())&#123; // 按照年龄升序排列 return 1; &#125; if( p1.getAge() &lt; p2.getAge())&#123; return -1; &#125; // 如果年龄相同则比较姓名 return p1.getNama().compareTo(p2.getNama()); &#125;&#125; public static void main(String[] args) &#123; TreeSet&lt;Person&gt; set = new TreeSet&lt;&gt;(new MyComparator()); // 传入比较器 set.add(new Person(\"张三\", 12)); set.add(new Person(\"李四\", 5)); set.add(new Person(\"李四\", 12)); set.add(new Person(\"tom\", 24)); set.add(new Person(\"tom\" , 24)); for (Person p: set)&#123; out.println(p.getNama()+\" \"+p.getAge()); &#125; &#125;输出： 李四 5张三 12李四 12tom 24可以看到重名的tom是相同的元素，智慧添加一个到TreeSet中，并且输出的顺序是按照年龄大小排列的 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。（无序） HashSet是按照哈希值来存数据的，所以取数据也是按照哈希值取得的。 Set具有元素的唯一性，所以HashSet也具有此特性。 HashSet如何检查重复呢？ ​ HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放对个元素。元素的哈希值是通过元素的hashCode方法来获取的， HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法；如果hashCode不一样就不会再调用equals方法了。如果equals方法返回true，那么HashSet认为新加入的对象重复了加入失败。如果equals方法为false那么HashSet认为新加入的对象没有重复，新元素可以加入。 LinkedHashSet 具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。（有序） 由链表保证元素有序 由哈希表保证元素唯一 2. List List特有的方法 1： 增加 ​ void add(int index, E elem) 指定位置添加元素 ​ boolean addAll(int index, COllection c) 指定位置添加集合 2： 删除 ​ E remove(int index) 删除指定位置元素 3： 查找 ​ E get(int index) 注意 IndexOutOfBoundsException ​ int indexOf(Object o) 找不到返回 -1 ​ lastIndexOf(Object o) 4： 修改 ​ E set(int index, E elem) 返回的是需要替换的集合中的元素 5： 求子集合 ​ List subList(int fromIndex, int toIndex) // 包含toIndex ArrayList 基于动态数组实现，支持随机访问。 底层采用数组实现， 默认为10. 查询快，增删慢。在实际开发过程中，ArrayList 是使用频率最高的一个集合。 Vector 和 ArrayList 类似，但它是线程安全的。描述的是一个线程安全的ArrayList ArrayList： 单线程效率高 Vector： 多线程安全， 所以效率低 特有的方法 ​ void addElement(E obj) 在集合末尾添加元素 ​ E elementAt(int index) 返回指定角标的元素 ​ Enumeration elements() 返回集合中的所有元素， 封装到Enumeration对象中 ​ Enumeration 接口： ​ boolean hashMoreElements() 测试此枚举的对象是否包含更多的元素 ​ E nextElement() 返回下一个元素 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 ​ 1. 特有方法： ​ addFirst(E e) ​ addLast(E e) ​ getFirst( ) ​ getLast( ) ​ removeFirst() ​ removeLast() 数据结构 1： 栈（1.6）：push() pop() 2: 队列 ： offer() poll() java123456789101112// 栈 LinkedList list = new LinkedList(); list.push(2); list.push(4); list.push(5); list.push(6); Iterator it = list.iterator(); while (it.hasNext())&#123; out.println(it.next()); &#125; 输出： 6 5 4 2 模拟队列： java1234567891011LinkedList q = new LinkedList(); q.offer(2); q.offer(3); q.offer(5); q.poll(); Iterator it1 = q.iterator(); while (it1.hasNext())&#123; out.println(it1.next()); &#125; 返回逆序的迭代器对 ​ descendingItrerator() 返回逆序的迭代器对象 3. Queue LinkedList ​ 可以用它来实现双向队列。 PriorityQueue ​ 基于堆结构实现，可以用它来实现优先队列。 总结 看到Array： 想到角标 看到Link： 想到first、last 看到Hash： 想到hashCode、equals 看到Tree： 想到两个接口： Comparable、 Comparator Map Map与Collection在框架中属并两列存在。interface Map&lt;K, V&gt; Map一次存储一对元素，Collection一次存一个。Map的键不能重复，保证唯一。 TreeMap ​ 基于红黑树实现。可以对键进行排序。排序方法和TreeSet中类似，对于不具备比较性的对象需要自定义比较器传入容器中。 HashMap ​ 基于哈希表实现， 无序，线程不同步，要保证键的唯一性，需要重写hashCode方法和equals方法。 HashTable 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 Hashtable不允许null值，HashMap允许null值（key和value都允许 ) 效率比HashMap低 LinkedHashMap ​ 继承了HashMap。使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 遍历 迭代器 迭代器： 为了方便处理集合中的元素，出现了迭代器对象。这个对象比较特殊，不能通过new来创建，它是以内部类的形式存在于每个集合的内部。 ​ 每个容器都能取出元素的功能，定义一样，只不过不同的容器使用的数据结构不同而导致取出元素的具体实现不一样，将共性抽取出来形成Iterator接口。每一个容易在其内部进行了内部类的实现。也就是将取出元素的方式的细节进行封装。 Iterable JDK1.5后的新接口。Collection继承了此接口，实现了Iterable的类就是可以进行迭代的，并且支持增强for循环。 Iterator Iterable 接口只有一个返回迭代器的方法Iterator(). Iterator是迭代器对象。 Iteartor Iterator() 返回该集合的迭代器对象 while循环进行迭代器遍历： java12345678910 LinkedList list = new LinkedList(); list.push(2); list.push(4); list.push(5); list.push(6);// 迭代器遍历 Iterator it = list.iterator(); while (it.hasNext()) &#123; out.println(it.next()); &#125; for循环： java123for (Iterator it = list.iterator(); it.hasNext();)&#123; out.println(it.next()); &#125; 推荐使用for循环，因为可以进行内存上的优化。 如果迭代器的指针已经指向了集合的末尾， 那么如果再调用next() 会返NoSuchElementException 异常。 如果调用move方法之前没用调用next是不合法的。会抛出IllegaStateException 迭代器原理 ArrayList： 看源码 java123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 看看Itr() 方法 java1234567891011121314151617181920212223242526272829303132333435363738private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return 下一个元素的下标 int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // 如果当前的下标大小不等于容器个元素个数 就 说明还有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; // 返回下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) // 没有下一个元素了 throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; // 当前的cursor要指向下一个 return (E) elementData[lastRet = i]; // 返回元素 &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; 来看看上面代码的checkForComodification(); java1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; ​ 在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作， 因为这样会产生安全隐患，java会抛出异常并发修改异常ConcurrentModificationException， 普通迭代器只支持在迭代过程中的删除操作。 java12345678910111213141516public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); list.add(\"eee\"); System.out.println(list); Iterator it = list.iterator(); while (it.hasNext())&#123; it.next(); it.remove(); list.add(\"aaaaa\"); // 出现了迭代器以外的对元素的操作 &#125; &#125; ​ 报错： List 特有的迭代器ListIterator 如果想在迭代元素的过程中操作集合的元素，那么可以使用LIst特有的迭代器对象ListIterator，该迭代器可支持在迭代的过程中添加元素和修改元素。 implements ListIterator 接口 java123public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; // 是否有前一个元素 public boolean hasPrevious() &#123; return cursor != 0; &#125; // 返回下一个元素的下标 public int nextIndex() &#123; return cursor; &#125; // 返回前一个元素的下标 public int previousIndex() &#123; return cursor - 1; &#125; // 返回前一个元素： 可以逆序访问 @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; // 用指定元素替换next或者 previous返回的最后一个元素 public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 将指定的元素加入列表，钙元素直接插入到next元素的后面 public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; 测试 set方法： java1234567891011121314public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); list.add(\"eee\"); System.out.println(list); ListIterator it = list.listIterator(); System.out.println(it.next()); it.set(\"zhu\"); System.out.println(list); &#125; 输出： [aaa, bbb, ccc, ddd, eee] aaa [zhu, bbb, ccc, ddd, eee] 测试 add方法 java12345678910111213public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); list.add(\"eee\"); System.out.println(list); ListIterator it = list.listIterator(); System.out.println(it.next()); it.add(\"zhu\"); // 在aaa之后添加zhu System.out.println(list); &#125; 输出： [aaa, bbb, ccc, ddd, eee] aaa [aaa, zhu, bbb, ccc, ddd, eee] 遍历Map 有三种方式： keySet() 获取Map中的所有键，转换成Set集合，然后遍历该Set，通过get方法获取键对应的值 values() 方法来获取所有值 ：Collection values() 不能获取到key对象 Map.Entry对象：重点！！！！推荐使用： Interface Map.Entry&lt;K,V&gt; Map.Entry public static interface Map.Entry&lt;K,V&gt; 将map集合中的键值对关系打包成一个Map.Entry对象，将该对象存入Set结合中，使用getKey() 和 getValue()来获取键和值 java1234567891011121314public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"aaa\", 123); map.put(\"bbb\", 345); map.put(\"ccc\", 121); map.put(\"ddd\", 675); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; s = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = s.iterator(); while (iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; en = iterator.next(); System.out.println(\"键： \"+ en.getKey()+\" 值：\"+ en.getValue()); &#125; &#125; 键： aaa 值：123 键： ccc 值：121 键： bbb 值：345 键： ddd 值：675 源码分析 如果没有特别说明，以下源码分析基于 JDK 1.8。 一、 ArrayList 1. 概览 因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。 java12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable java1234/** * Default initial capacity. 数组的默认大小为10 */ private static final int DEFAULT_CAPACITY = 10; 2. 扩容 ​ 添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1) ，也就是旧容量的 1.5 倍。 ​ 扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 java12345678910111213141516171819202122232425262728293031public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;// private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 3. 删除元素 需要调用 `System.arraycopy()` 将 `index+1 ` 后面的元素都复制到 `index` 位置上，该操作的时间复杂度为 `O(N)`，可以看到 ArrayList 删除元素的代价是非常高的。 java1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 4. 序列化 ​ ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。 ​ 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 java1transient Object[] elementData; // non-private to simplify nested class access ​ ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。 java123456789101112131415161718192021222324252627/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). 反序列化 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; java123456789101112131415161718192021222324252627/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). 序列化 * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. 只序列化数组中有元素填充那部分内容 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; ​ 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。 5. Fail-Fast ​ modCount 用来记录 ArrayList 结构发生变化的次数。 ​ 结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 ​ 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。 ​ fail-fast 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 ​ ConcurrentModificationException 异常 ： 当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。 ​ 诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。 ​ 线程环境下产生该异常的原因是在迭代器遍历集合时，使用了集合本身的remove方法而不是迭代器的； java1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; ​ 在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。 fail-fast会在以下两种情况下抛出ConcurrentModificationException ： （1）单线程环境 集合被创建后，在遍历它的过程中修改了结构。 注意 remove()方法会让expectModcount和modcount 相等，所以是不会抛出这个异常。 （2）多线程环境 当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。 问题： fail-fast机制是如何检测的？ ​ 迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “modCount” ，当集合结构改变（添加删除或者修改），标记&quot;modCount“会被修改，而迭代器每次的hasNext()和next()方法都会检查该”modCount&quot;是否被改变，当检测到被修改时，抛出ConcurrentModificationException 单线程情况 java123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + \"\"); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; if (i == 3) &#123; list.remove(3); &#125; System.out.println(iterator.next()); i ++; &#125;&#125; 上述代码是ArrayList单线程环境下的fail-fast ， 该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。 如果将以上代码修改成在next之后进行迭代器的remove操作，就不会报错。 java1234567891011121314151617public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i++ ) &#123; list.add(i + \"\"); &#125; Iterator&lt;String&gt; iterator = list.iterator(); int i = 0 ; while(iterator.hasNext()) &#123; System.out.println(iterator.next()); if (i == 3) &#123; iterator.remove(); // 在next之后进行迭代器的remove操作 &#125; i ++; &#125; System.out.println(list); &#125; 输出： 0 1 2 3 4 5 6 7 8 9 [0, 1, 2, 4, 5, 6, 7, 8, 9] ​ 所以，在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作， 因为这样会产生安全隐患，java会抛出异常并发修改异常ConcurrentModificationException， 普通迭代器只支持在迭代过程中的删除操作。 类似的，hashMap中发生的原理也是一样的。 HashMap发生fail-fast ： java12345678910111213141516public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; 10 ; i ++ ) &#123; map.put(i+\"\", i+\"\"); &#125; Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); int i = 0; while (it.hasNext()) &#123; if (i == 3) &#123; map.remove(3+\"\"); &#125; Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); i++; &#125;&#125; 该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了ConcurrentModificationException异常： ​ 类似，next之后调用迭代器的remove就可以成功删除。 多线程情况 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * @author Hongliang Zhu * @create 2020-02-10 12:53 */public class FailFastTest &#123; public static List&lt;String&gt; list = new ArrayList&lt;&gt;(); private static class MyThread1 extends Thread &#123; @Override public void run() &#123; Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) &#123; String s = iterator.next(); System.out.println(this.getName() + \":\" + s); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125; &#125; private static class MyThread2 extends Thread &#123; int i = 0; @Override public void run() &#123; while (i &lt; 10) &#123; System.out.println(\"thread2:\" + i); if (i == 2) &#123; list.remove(i); &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; i ++; &#125; &#125; &#125; public static void main(String[] args) &#123; for(int i = 0 ; i &lt; 10;i++)&#123; list.add(i+\"\"); &#125; MyThread1 thread1 = new MyThread1(); MyThread2 thread2 = new MyThread2(); thread1.setName(\"thread1\"); thread2.setName(\"thread2\"); thread1.start(); thread2.start(); &#125;&#125; 启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException 避免fail-fast 方法一: 在单线程的遍历过程中，如果要进行`remove`操作，可以调用迭代器的`remove`方法而不是集合类的`remove`方法。看看ArrayList中迭代器的remove方法的源码: java1234567891011121314public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; /// 不会修改modCount，而是令其余expectedModCount相等 &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; ​ 可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。该方法有局限性，就是上面说的，只能代用next方法之后再调用迭代器的remove方法。 方法二：安全失败 ​ 使用java并发包(java.util.concurrent)中的类来代替ArrayList 和hashMap。 ​ 比如使用 CopyOnWriterArrayList代替ArrayList，CopyOnWriterArrayList在是使用上跟ArrayList几乎一样，CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。 ​ 对于HashMap，可以使用ConcurrentHashMap，ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是：在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。 6. 安全失败（fail—safe） 快速失败（Fail-Fast）的场景： `java.util`包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 ​ 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。比如上面说的COW **原理：**由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 **缺点：**基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 ​ 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 并发修改 ： 当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。这就是并发修改 。 fail-safe机制有两个问题 （1）需要复制集合，产生大量的无效对象，开销大。 （2）无法保证读取的数据是目前原始数据结构中的数据。 7. fail-fast和 fail-safe 的区别 Fail Fast Iterator Fail Safe Iterator Throw ConcurrentModification Exception Yes No Clone object No Yes Memory Overhead No Yes Examples HashMap,Vector,ArrayList,HashSet CopyOnWriteArrayList, ConcurrentHashMap 二、 Vector java123public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 也继承了RandomAccess接口， 可以随机访问。 1. 同步 **它的实现与 ArrayList 类似，但是使用了 `synchronized` 进行同步。** java12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 2 . 扩容 ​ Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。 java1234567891011121314151617/** * Constructs an empty vector with the specified initial capacity and * capacity increment. 构造函数 * * @param initialCapacity 数组的初始容量 * @param capacityIncrement 扩容时使容量 `capacity` 增长 `capacityIncrement` * @throws IllegalArgumentException if the specified initial capacity * is negative */ public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; java123456789101112private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; ​ 调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。 java1234567public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;public Vector() &#123; this(10);&#125; 3. 与ArrayList的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。 4. 替代方案 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 Code12List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();List&lt;String&gt; synList &#x3D; Collections.synchronizedList(list); Code1234567891011public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : new SynchronizedList&lt;&gt;(list)); &#125; static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list, mutex) : new SynchronizedList&lt;&gt;(list, mutex)); &#125; 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 java1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); 三、 CopyOnWriteArrayList 1. 读写分离 写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 java1234567891011121314151617181920212223242526272829/** * Appends the specified element to the end of this list. * 添加一个元素： 写操作 * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); // 加锁 try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); // 复制数组 newElements[len] = e; setArray(newElements); // 写操作结束之后需要把原始数组指向新的复制数组。 return true; &#125; finally &#123; lock.unlock(); // 去锁操作 &#125; &#125;final void setArray(Object[] a) &#123; array = a;&#125;@SuppressWarnings(\"unchecked\")private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 2. 适用场景 ​ CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 ​ 但是 CopyOnWriteArrayList 有其缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。 四、 Collections 与 Arrays 集合框架中的工具类中的方法都是静态的 Collection中的常见方法： 对List进行二分查找： int binarySearch(list, key) ​ int binarySearch(list, key, Comparator) ​ 二分查找需要列表有序 对list集合进行排序 sort(list): 其实是使用list容器中对象的CompareTo方法 sort(list, comparator) //按照指定比较器进行排序 对集合取最大值或者最小值 ​ max（collection） min（collection） 对集合进行反转 ​ reverse(list) 对比较方式强行逆转 ​ Comparator reverseOrder(); ​ Comparator reverseOrder(Comparator); 对list中的元素的位置进行替换 ​ swap(list, x, y); 对集合中的元素进行替换， 如果被替换的元素不存在， 那么原来的集合不变 ​ replaceAll(list, old, new); 将集合变成数组 ​ Collection.toArray() 【collection不是Collections工具类】 Arrays： 用于对数组操作的工具类: Arrays.方法() 二分查找， 需要数组有序 binarySearch(int []) 数组排序 sort(int []) 将数组变成字符串 toString(int []) 复制数组 ​ copyOf() 复制部分数组 copyOfRange() 比较两个数组是否相同 equals(int [], int []) 将数组变成集合： List asList(T []) 这样可以通过结合的操作来操作数组中的元素，但是不可以死使用增删方法， add， remove，因为数组的长度固定，会出现UnsupportOperationException. 五、 LinkedList 1. 概览 ​ 基于双向链表实现，使用 Node 存储链表节点信息。 java123456789101112131415161718192021222324252627public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** * Constructs an empty list. */ public LinkedList() &#123; &#125; ...&#125; 每个链表存储了first和last指针，用Node来保存链表节点信息 java1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 2.与ArrayList的比较 ​ ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别： 数组支持随机访问，但插入删除的代价很高，需要移动大量元素； 链表不支持随机访问，但插入删除只需要改变指针。 六、 HashMap 为了便于理解，以下源码分析以 JDK 1.7 为主。 1. 存储结构 内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。 以下源码基于JDK1.7 java1transient Entry[] table; java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; ​ HashMap中两个参数会影响他的性能：初始容量和装载因子。初始容量是指哈希表中桶的个数，即哈希表的大小； 装载因子是表示hash表中元素的填满的程度，装 载因子越大，填满的元素越多，好处是，空间利用率高了，但冲突的机会加大了；反之，加载因子越小，填满的元素越少，好处是冲突的机会减小了，但空间浪费多了。 ​ 冲突的机会越大，则查找的成本越高。反之，查找的成本越小，查找时间就越小。 因此，必须在 &quot;冲突的机会&quot;与&quot;空间利用率&quot;之间寻找一种平衡与折衷，这种平衡与折衷本质上是数据结构中有名的**&quot;时-空&quot;矛盾**的平衡与折衷。 ​ HashMap默认的装载因子是0.75，最大容量是16，因此可以得出HashMap的默认容量是：0.75*16=12。 用户可以自定义最大容量和装载因子。 ​ HashMap 包含如下几个构造器： HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。 HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。 HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。 2. 拉链法工作原理 java1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 ​ 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 ​ 3. put操作 java1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 java12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; ​ 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 java12345678910111213141516void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; Code123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value &#x3D; v; next &#x3D; n; key &#x3D; k; hash &#x3D; h;&#125; 在JDK1.8中的put操作： 思路如下： 1.table[]是否为空 2.判断table[i]处是否插入过值 3.判断链表长度是否大于8，如果大于就转换为红黑二叉树，并插入树中 4.判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value 5.如果key不相同，就插入一个key，记录结构变化一次 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断table是否为空，如果是空的就创建一个table，并获取他的长度 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果计算出来的索引位置之前没有放过数据，就直接放入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; //进入这里说明索引位置已经放入过数据了 Node&lt;K,V&gt; e; K k; //判断put的数据和之前的数据是否重复 //key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //判断是否是红黑树，如果是红黑树就直接插入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 转换为红黑树 break; &#125; // 判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key，因此只需要将value覆盖，并将oldValue返回即可 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数 ++modCount; if (++size &gt; threshold) // 扩容 resize(); afterNodeInsertion(evict); // 这个是给LinkedHashMap用的，HashMap里也是个空实现 return null; // 添加成功返回null &#125; get方法 java12345678910111213141516171819202122232425262728293031public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 4. 确定桶下标 很多操作都需要先确定一个键值对所在的桶下标。 java12int hash = hash(key);int i = indexFor(hash, table.length); 4.1 计算 hash 值（1.7） java1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; java123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 4.2 取模 令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质： c12x : 00010000x-1 : 00001111 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数： java123y : 10110010x-1 : 00001111y&amp;(x-1) : 00000010 这个性质和 y 对 x 取模效果是一样的： java123y : 10110010x : 00010000y%x : 00000010 我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。 java123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 4.4 在JDK1.8中的hash方法 hash()方法其实顾名思义就是用来获取key的hash的一个hash值的,但是HashMap里的hash()方法似乎与一般的直接key.hashCode()不太一样，我们先看看它到底是什么样的神奇操作。 其源码如下: java12345static final int hash(Object key) &#123; int h; // key是null就返回0，key不是null就先取hashCode（）然后与这个hashCode（）无符号右移进行亦或运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 将hashCode的值异或他的高16位获取到hash值&#125; ​ 这是因为找key的位置时，(n - 1) &amp; hash是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高 ​ 为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。 ​ 我们知道hashCode本身是一个32位的int类型，进行这样的操作就等于将hashCode的高16位异或它的低16位得到一个新的hash值。 但是拿到这样一个hash值的作用是什么呢？我们可以先想一下如何利用key的hash值确定每个key的哈希桶索引位置而且还需要尽量均衡。第一个想到的当然是用hash值对哈希桶的长度(length)进行取模的操作。即: index = hash % length 这种方式可以用随机的hash值算出随机的索引并且分配也尽量均匀。没错！!HashMap也是这么想的。但是这种取模运算本身是对CPU运算开销比较大的，为了优化速度，HashMap采取了更优雅的方式，在putVal的核心代码可以看到HashMap采用了hash值&quot;与&quot;length-1的方式来确定索引位置。即： ​ index = hash &amp; length-1 hash()方法中的高16位异或16位的计算方式，是在JDK1.8之后才加上的，在JDK1.7及之前的版本里是indexFor()方法，直接用hashCode&amp;length-1计算出索引位置。这个是jdk1.7和jdk1.8中的区别。 5. 扩容-基本原理 设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。 为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。 和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。 参数 含义 capacity table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 size 键值对数量。 threshold size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 loadFactor 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。 java12345678910111213141516static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认的初始容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大容量 2 的 30次方static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认的装载因子为0.75transient Entry[] table;transient int size; // size就是HashMap中键值对的总个数。int threshold; // size 的临界值final float loadFactor;transient int modCount; // 记录是发生内部结构变化的次数， fail-fast需要用 // 如果put值，但是put的值是覆盖原有的值，这样是不算内部结构变化的。 ​ threshold=装载因子 * capacity ，也就是说数组长度固定以后， 如果负载因子越大，所能容纳的元素个数越多，如果超过这个值就会进行扩容(默认是扩容为原来的2倍)，0.75这个值是权衡过空间和时间得出的，建议大家不要随意修改，如果在一些特殊情况下，比如空间比较多，但要求速度比较快，这时候就可以把扩容因子调小以较少hash冲突的概率。相反就增大扩容因子(这个值可以大于1)。 ​ 因为HashMap扩容每次都是扩容为原来的2倍，所以capacity 总是2的次方，这是非常规的设置，常规设置是把桶的大小设置为素数，因为素数发生hash冲突的概率要小于合数，比如HashTable的默认值设置为11，就是桶的大小为素数的应用(HashTable扩容后不能保证是素数)。HashMap采用这种设置是为了在取模和扩容的时候做出优化。 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 java123456void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length); // 两倍扩容&#125; 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 java1234567891011121314151617181920212223242526272829303132void resize(int newCapacity) &#123;// 传入新的容量 Entry[] oldTable = table; // 引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor); //修改阈值&#125;/* 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 */void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null; //释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; ​ newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 ​ 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 ​ 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 ​ 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： ​ 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： ​ 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 6. 扩容-重新计算桶下标 ​ 在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。 ​ 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32： c++12capacity : 00010000new capacity : 00100000 对于一个 Key，它的哈希值 hash 在第 5 位： 为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致； 为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。 7. 计算数组容量 ​ 这里先了解一下基本的位运算 运算符 计算方式 与 &amp; 只有两个数同一位都是1才会返回1 或 l 两个数同一位只要存在一个1就是1 异或 ^ 两个数同一位不能相同才为1 左移 &lt;&lt; 所有位置左移，低位补0 右移 &gt;&gt; 正数：所有位置右移，高位补0 负数：写出补码（符号位不变，其余位置取反，然后加1），所有位置右移高位补1，然后再获取原码（符号位不变，其余位置取反，然后加1） 无符号右移 &gt;&gt; 无论正负高位补0 ​ HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 用num与num左移的数字做或运算赋给num 。 c123mask |= mask &gt;&gt; 1 11011000mask |= mask &gt;&gt; 2 11111110mask |= mask &gt;&gt; 4 11111111 mask+1 是大于原始数字的最小的 2 的 n 次方。 c12num 10010000mask+1 100000000 以下是 HashMap 中计算数组容量的代码： java123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 8. 链表转红黑树 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。 参考 https://cyc2018.github.io/CS-Notes 超详细的HashMap解析(jdk1.8) HashMap JDK1.8实现原理 java中的fail-fast(快速失败)机制 面试题思考：java中快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ Java 8系列之重新认识HashMap","categories":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://castile.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"leetcode-399-除法求值","slug":"leetcode-399-除法求值","date":"2020-01-31T14:30:10.000Z","updated":"2020-01-31T15:25:59.910Z","comments":true,"path":"2020/01/31/leetcode-399-除法求值/","link":"","permalink":"https://castile.github.io/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/","excerpt":"","text":"描述 给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。 示例 : 给定 a / b = 2.0, b / c = 3.0 问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 返回 [6.0, 0.5, -1.0, 1.0, -1.0 ] 输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector类型。 基于上述例子，输入如下： equations(方程式) = [ [“a”, “b”], [“b”, “c”] ], values(方程式结果) = [2.0, 3.0], queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ]. 输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。 链接：https://leetcode-cn.com/problems/evaluate-division 此题难度为中等，但是我做了一天…， 太菜了。。。对于我来说还是比较复杂的题目了。 分析 dfs：使用深度优先搜索就比较直观。每个字母相当于一个节点，在给定的equations中建立合适的数据结构，建图，要求方程式的结果相当于求两个节点之间是否可以到达，可以到达则求出其代价，不能到达就设为-1.0. 我觉得此题的关键就是建图。 a/c = (a/b) * (b/c)，所以我们可以用图来解决 。 并查集： 比较特殊，在路径压缩那块比较复杂。。。以后补上吧 代码 Leetcode AC 代码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; // 使用map的数据结构更好 // 表示 a-&gt;b 的权重 即 a / b 的值 Map&lt;String, Map&lt;String, Double&gt;&gt; g = new HashMap&lt;&gt;(); buildGraph(g, equations, values); double[] res = new double[queries.size()]; Arrays.fill(res, -1.0); int index= 0 ; for(List&lt;String&gt; q: queries)&#123; String a = q.get(0); String b = q.get(1); if(!g.containsKey(a) || !g.containsKey(b))&#123; index++; &#125;else&#123; dfs(g, a, b, res, new HashSet&lt;&gt;(), index, 1.0); index++; &#125; &#125; return res; &#125; // 建图 private void buildGraph(Map&lt;String, Map&lt;String, Double&gt;&gt; g, List&lt;List&lt;String&gt;&gt; equations, double[] values)&#123; int index = 0; for(List&lt;String&gt; e: equations)&#123; String a = e.get(0); String b = e.get(1); g.putIfAbsent(a, new HashMap&lt;&gt;()); g.putIfAbsent(b, new HashMap&lt;&gt;()); g.get(a).put(b, values[index]); // a / b g.get(b).put(a, 1.0 / values[index]); // b / a index++; g.get(a).put(a, 1.0); g.get(b).put(b, 1.0); &#125; &#125; private void dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, double[] res, Set&lt;String&gt; visited, int index, double tmp) &#123; visited.add(a); if(g.get(a) == null || g.get(a).size() == 0)&#123; // 说明a没有与其他点相连 return; &#125; if(g.get(a).containsKey(b))&#123; // 刚好有a-&gt;b的路径 res[index] = g.get(a).get(b) * tmp; return; &#125; for(String next: g.get(a).keySet())&#123; if(visited.contains(next)) continue; dfs(g, next, b, res, visited, index, g.get(a).get(next)*tmp); &#125; &#125;&#125; 还有一些问题未解决，比如下面是自己写的代码，在idea上运行没毛病，但是在leetcode上就出错了。具体原因不详，欢迎大家提出问题进行交流，不胜感激！ java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class Solution_DFS&#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; g = new HashMap&lt;&gt;(); // 图 bulidGraph(g, equations, values); double[] res = new double[queries.size()]; // 结果集合 Arrays.fill(res, -1.0); // 全部设置成-1.0； int index = 0; // 遍历问题式子 for(List&lt;String&gt; q: queries)&#123; String a = q.get(0); String b = q.get(1); if(!g.containsKey(a) || !g.containsKey(b))&#123; index++; &#125;else &#123; dfs(g, a, b, res, index, new HashSet&lt;&gt;(), 1.0); index++; &#125; &#125; return res; &#125; // 下面这个方法在leetcode行不通 public double[] calcEquation_dfs(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; g = new HashMap&lt;&gt;(); bulidGraph(g, equations, values); int index = 0; double[] ans = new double[queries.size()]; for (List&lt;String&gt; q: queries)&#123; String x = q.get(0); String y = q.get(1); if(!g.containsKey(x) || !g.containsKey(y))&#123; ans[index] = -1.0; index++; continue; &#125; HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); ans[index] = divide(x, y, g, visited); index++; &#125; return ans; &#125; // get a / b private double divide(String a, String b, Map&lt;String, Map&lt;String, Double&gt;&gt; g, Set&lt;String&gt; visitied)&#123; if( a == b)&#123; return 1.0; &#125; visitied.add(a); for(String next: g.get(a).keySet())&#123; if(visitied.contains(next)) continue; double d = divide(next, b, g, visitied); // d = next / b // a /b = next /b * a / next if(d &gt; 0) return d * g.get(a).get(next); &#125; return -1.0; &#125; private void dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, double[] res, int index, Set&lt;String&gt; visited, double tmp)&#123; visited.add(a); if(g.get(a) == null || g.get(a).size() == 0)&#123; return; &#125; if(g.get(a).containsKey(b)) &#123; // 刚好存在 a-&gt;b res[index] = g.get(a).get(b) * tmp; return; &#125; for(String next: g.get(a).keySet())&#123; if(visited.contains(next)) continue; dfs(g, next, b, res, index, visited, g.get(a).get(next) * tmp); &#125; &#125; private void bulidGraph(Map&lt;String, Map&lt;String, Double&gt;&gt; g , List&lt;List&lt;String&gt;&gt; equations, double[] values)&#123; int index = 0; for(List&lt;String&gt; e: equations)&#123; String a = e.get(0); String b = e.get(1); g.putIfAbsent(a, new HashMap&lt;&gt;()); g.putIfAbsent(b, new HashMap&lt;&gt;()); g.get(a).put(b, values[index]); // a -&gt; b : a / b g.get(b).put(a, 1.0 / values[index]); // b -&gt; a : b / a; index++; g.get(a).put(a, 1.0); g.get(b).put(b, 1.0); // 自己到自己的权重为1 &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"搜索","slug":"搜索","permalink":"https://castile.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"leetcode-547-朋友圈","slug":"leetcode-547-朋友圈","date":"2020-01-30T06:15:07.000Z","updated":"2020-01-31T15:21:15.155Z","comments":true,"path":"2020/01/30/leetcode-547-朋友圈/","link":"","permalink":"https://castile.github.io/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/","excerpt":"","text":"描述 Leetcode547：Friend_Circles 朋友圈 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 输入: [[1,1,0], [1,1,0], [0,0,1]] 输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。 第2个学生自己在一个朋友圈。所以返回2。 示例 2: 输入: [[1,1,0], [1,1,1], [0,1,1]] 输出: 1 说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 链接：https://leetcode-cn.com/problems/friend-circles 并查集、dfs、bfs 分析 并查集：转化为求连通个数。 好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友， 那么 M[0][1]和 M[1][0]的值都为 1。 很简单直观。 并查集： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 并查集 UFpublic class UF &#123; private int count = 0; // 连通分量 private int[] parent; // 新增一个数组记录树的“重量” private int[] size; // 构造 public UF(int n)&#123; // n个元素 this.count = n; size = new int[n]; parent = new int[n]; // 一开始每一个节点自成一个集合，都不连通 for (int i = 0; i &lt; n; i++)&#123; parent[i] = i; // 自己的父节点指向自己 size[i] = 1; // 每隔几何只有自身一个元素 &#125; &#125; public int find(int x)&#123; int root = parent[x]; while (parent[x] != x)&#123; // 路径压缩 x = parent[x]; &#125; return x; &#125; public boolean isSameSet(int a, int b)&#123; return find(a) == find(b); &#125; public int count()&#123; return count; &#125; public void union(int a, int b)&#123; int rootA = find(a); int rootB = find(b); if(rootA == rootB)&#123; return; // 同一个集合不能合并 &#125;else&#123; if(size[rootA] &gt; size[rootB])&#123; parent[rootB] = rootA; size[rootA] += size[rootB]; &#125;else &#123; parent[rootA] = rootB; size[rootB] += size[rootA]; &#125; &#125; count--; // 连通分量个数减一 &#125;&#125; dfs： 给定的矩阵可以看成图的邻接矩阵。这样我们的问题可以变成无向图连通块的个数。 M= [1 1 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 1] ​ 如果我们把 M 看成图的邻接矩阵，则图为： ​ 在这个图中，点的编号表示矩阵 M 的下标，i 和 j之间有一条边当且仅当M[i][j]为 1。 ​ 为了找到连通块的个数，一个简单的方法就是使用深度优先搜索，从每个节点开始，我们使用一个大 小为 N 的 visited数组（M大小为 N×N ），这样 visited[i] 表示第 i 个元素是否被深度优先搜索访问过。每使 用一次深度优先搜索，即重新选择了一个点进行dfs，连通分量的个数就加一。 bfs: 方法与dfs类似，只是遍历方式是层次遍历， 使用的数据结构是队列。在广度优先搜索中，我们从一个特定点开始，访问所有邻接的节点。然后对于这些邻接节点，我们依然通过访问邻接节点的方式，知道访问所有可以到达的节点。因此，我们按照一层一层的方式访问节点。 代码 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package search;import java.util.LinkedList;import java.util.Queue;/** * @author Hongliang Zhu * @create 2020-01-29 20:57 */public class leetcode547_FriendCircles &#123; // 深度优先 public static void dfs(int[][] M, int[] visited, int i) &#123; for (int j = 0; j &lt; M.length; j++) &#123; if (M[i][j] == 1 &amp;&amp; visited[j] == 0) &#123; // 是连通的并且还未访问 visited[j] = 1; dfs(M, visited, j); &#125; &#125; &#125; public static int findCircleNum_DFS(int[][] M) &#123; int count = 0; int n = M.length; int[] visited = new int[n]; for (int i = 0; i &lt; n; i++) &#123; if (visited[i] == 0) &#123; dfs(M, visited, i); count++; // 执行一次dfs表示增加了一个连通块 &#125; &#125; return count; &#125; /* 下面使用并查集 */ static int []parents; static int []size; static int count1 = 0; // 连通分量 public static void makeSet(int n)&#123; parents = new int[n]; size = new int[n]; count1 = n; for(int i = 0; i &lt; n; i++)&#123; size[i] = 1; parents[i] = i; &#125; &#125; public static int find(int a)&#123; int root = parents[a]; while(root!= parents[root])&#123; root = parents[root]; &#125; return root; &#125; public static void union(int a, int b)&#123; int roota = find(a); int rootb = find(b); if(roota != rootb)&#123; if(size[roota] &gt; size[rootb])&#123; parents[rootb] = roota; size[roota] = size[roota]+size[rootb]; &#125;else&#123; parents[roota] = rootb; size[rootb] = size[roota]+size[rootb]; &#125; count1--; &#125; &#125; public static int findCircleNum(int[][] M) &#123; int n = M.length; makeSet(n); for(int i = 0; i&lt; n; i++)&#123; for( int j = i+1; j &lt; n; j++)&#123; if(M[i][j] == 1)// 朋友 &#123; union(i, j); &#125; &#125; &#125; return count1; // 返回连通分量的个数 &#125; // 广度优先遍历 public static int findCircleNum_BFS(int[][] M) &#123; int n = M.length; int count = 0; int[] visited = new int[n]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; n; i++)&#123; if(visited[i] == 0)&#123; queue.add(i); while (!queue.isEmpty())&#123; int k = queue.remove(); visited[k] = 1; for(int j = 0; j &lt; n; j++)&#123; if(M[k][j] == 1 &amp;&amp; visited[j] == 0) queue.add(j); &#125; &#125; count++; &#125; &#125; return count; &#125; public static void main(String[] args) &#123; int[][] M = &#123;&#123;1, 1, 0&#125;, &#123;1, 1, 0&#125;, &#123;0, 0, 1&#125;&#125;; System.out.println(findCircleNum_DFS(M)); // 2 System.out.println(findCircleNum_BFS(M));// 2 System.out.println(findCircleNum(M));// 2 &#125;&#125; 注： 使用并查集速度最快。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"搜索","slug":"搜索","permalink":"https://castile.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"bfs","slug":"bfs","permalink":"https://castile.github.io/tags/bfs/"}]},{"title":"Java关键字","slug":"Java关键字","date":"2020-01-29T02:19:02.000Z","updated":"2020-01-29T03:16:50.490Z","comments":true,"path":"2020/01/29/Java关键字/","link":"","permalink":"https://castile.github.io/2020/01/29/Java%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"final 1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 java1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 static 1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 java123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 java12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。 即静态域中不能访问非静态的，因为静态的变量是先于对象（或者非静态）出现。 java1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 java123456789101112public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125;// 结果只输出一次“123” 4. 静态内部类 内部类 大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类） 内部类的作用 更好的封装性 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量 匿名内部类适合用于创建那些仅需要一次使用的类 使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，static关键字的作用是把类的成员变成类相关，而不是实例相关 。 注意： 非静态内部类中不允许定义静态成员 2. 外部类的静态成员不可以直接使用非静态内部类 3. 静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员 在建造者模式中有使用，具体可以参考链接 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 java123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125;Copy to clipboardErrorCopied 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 java1import static com.xxx.ClassName.* 一般我们导入一个类都用 import com…..ClassName; 而静态导入是这样：import static com…..ClassName.*; 这里的多了个static，还有就是类名ClassName后面多了个.* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。 好处： 这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…); 就可以将其写入一个静态方 法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。 java12345678910111213141516import static java.lang.System.out;/** * @author Hongliang Zhu * @create 2020-01-29 10:40 */public class keywords &#123; static &#123; out.println(\"hello\"); &#125; public static void main(String[] args) &#123; &#125;&#125; 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 java1public static String staticField = \"静态变量\"; java123static &#123; System.out.println(\"静态语句块\");&#125; java1public String field = \"实例变量\"; java123&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化 java123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 参考 https://cyc2018.github.io/CS-Notes https://blog.csdn.net/cd18333612683/article/details/79129503 https://blog.csdn.net/u012338954/article/details/51010337","categories":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/tags/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"https://castile.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"关键字","slug":"关键字","permalink":"https://castile.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"}]},{"title":"leetcode-990-等式方程的可满足性","slug":"leetcode-990-等式方程的可满足性","date":"2020-01-28T14:45:18.000Z","updated":"2020-01-28T14:56:47.405Z","comments":true,"path":"2020/01/28/leetcode-990-等式方程的可满足性/","link":"","permalink":"https://castile.github.io/2020/01/28/leetcode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/","excerpt":"","text":"描述 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：“a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 输入：[“a==b”,“b!=a”] 输出：false 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 输出：[“ba&quot;， &quot;ab”] 输入：true 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3： 输入：[“ab&quot;,&quot;bc”,“a==c”] 输出：true 示例 4： 输入：[“ab&quot;, “b!=c”,&quot;ca”] 输出：false 示例 5： 输入：[“cc&quot;, &quot;bd”, “x!=z”] 输出：true 链接：https://leetcode-cn.com/problems/satisfiability-of-equality-equations 分析 根据等式的传递性，可以想到使用并查集非常快速可以解决此题。动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 == 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。 核心思想是，将 equations 中的算式根据 == 和 != 分成两部分，先处理 == 算式，使得他们通过相等关系各自勾结成门派；然后处理 != 算式，检查不等关系是否破坏了相等关系的连通性。 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.ArrayList;import java.util.Stack;/** * @author Hongliang Zhu * @create 2020-01-28 21:28 */public class leetcode990_SatisfiabilityOfEqualityEquations &#123; // 并查集 public static boolean equationsPossible(String[] equations) &#123; UF uf = new UF(26); // 26个字母 // 所有等式连通 for (String eq : equations) &#123; if (eq.charAt(1) == '=') &#123; // 判断为等式 char x = eq.charAt(0); char y = eq.charAt(3); uf.union(x - 'a', y - 'a'); &#125; &#125; // 判断不等式会不会破坏连通性 for (String eq : equations) &#123; if (eq.charAt(1) == '!') &#123; // 判断为不等式 char x = eq.charAt(0); char y = eq.charAt(3); if (uf.isSameSet(x - 'a', y - 'a')) &#123; return false; &#125; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; String[] equations1 = &#123;\"c==c\", \"b==d\", \"x!=z\"&#125;; System.out.println(equationsPossible(equations1)); // true String[] equations2 = &#123;\"a==b\", \"b==c\", \"a==c\"&#125;; System.out.println(equationsPossible(equations2)); // true String[] equations3 = &#123;\"b==a\", \"a!=b\"&#125;; System.out.println(equationsPossible(equations3)); // fasle &#125;&#125; dfs，图的联通性，染色问题，这是leetcode官方题解： ​ 思路： 所有相互等于的变量能组成一个联通分量。举一个例子，如果 a=b, b=c, c=d，那么 a, b, c, d 就在同一个联通分量中，因为它们必须相等。 ​ 第一步，我们基于给定的等式，用深度优先遍历将每一个变量按照联通分量染色。 ​ 将联通分量染色之后，我们分析形如 a != b 的不等式。如果两个分量有相同的颜色，那么它们一定相等，因此 如果说它们不相等的话，就一定无法满足给定的方程组。返回false。 代码 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.ArrayList;import java.util.Stack;/** * @author Hongliang Zhu * @create 2020-01-28 21:28 */public class leetcode990_SatisfiabilityOfEqualityEquations &#123; //连通 染色 public static boolean equationsPossible_DFS(String[] equations) &#123; ArrayList&lt;Integer&gt;[] graph = new ArrayList[26]; // 26个字母 // 初始化 for (int i = 0; i &lt; 26; i++) &#123; graph[i] = new ArrayList&lt;Integer&gt;(); &#125; // 等式进行连通 for (String eq : equations) &#123; if (eq.charAt(1) == '=') &#123; char x = eq.charAt(0); char y = eq.charAt(3); graph[x - 'a'].add(y - 'a'); graph[y - 'a'].add(x - 'a'); &#125; &#125; int[] color = new int[26]; // 准备26种颜色 int t = 0; for (int i = 0; i &lt; 26; i++) &#123; if (color[i] == 0) &#123; // 第i个字母还没染色 t++; // 增加一种颜色 Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); s.push(i); while (!s.isEmpty()) &#123; int node = s.pop(); for (int nn : graph[node]) &#123;// 取出与node连通的所有点， 即取出等式两边的字母 if (color[nn] == 0) &#123; color[nn] = t; // 连通的节点设置成相同的颜色 s.push(nn); // 将与之连通的节点进栈，实现等式传递性的功能 &#125; &#125; &#125; &#125; &#125; // 检查不等式的合法性 for (String eq : equations) &#123; if (eq.charAt(1) == '!') &#123; int x = eq.charAt(0) - 'a'; int y = eq.charAt(3) - 'a'; if (x == y || color[x] != 0 &amp;&amp; color[x] == color[y]) &#123; // 字母相等，颜色相同的一定不满足不等关系 return false; &#125; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; String[] equations1 = &#123;\"c==c\", \"b==d\", \"x!=z\"&#125;; String[] equations2 = &#123;\"a==b\", \"b==c\", \"a==c\"&#125;; String[] equations3 = &#123;\"b==a\", \"a!=b\"&#125;; System.out.println(equationsPossible_DFS(equations1)); // true System.out.println(equationsPossible_DFS(equations2)); // true System.out.println(equationsPossible_DFS(equations3)); // false &#125;&#125; 复杂度分析 时间复杂度： O(N)，其中 N是方程组 equations 的数量。 空间复杂度： O(1），认为字母表的大小是 O(1) 的。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"}]},{"title":"Java的自动装箱和拆箱","slug":"Java的自动装箱和拆箱","date":"2020-01-28T03:57:55.000Z","updated":"2020-01-28T04:10:07.861Z","comments":true,"path":"2020/01/28/Java的自动装箱和拆箱/","link":"","permalink":"https://castile.github.io/2020/01/28/Java%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/","excerpt":"","text":"自动装箱/拆箱 自动装箱：指开发人员可以把一个基本数据类型直接赋给对应的包装类。 自动拆箱：指开发人员可以把一个包装类对象直接赋给对应的基本数据类型。 基本数据类型包装类 包装类 基本数据类型 Byte byte Integer int Long long Boolean boolean Float float Double double Character char 对象变基本数据类型:拆箱 基本数据类型包装为对象:装箱 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。 Example： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Demo5 &#123; public static void main(String[] args) &#123; String str = \"12\"; //字符串转换成int类型数据。 可以把字符串转换成对应的数字 int i = Integer.parseInt(str); System.out.println(i+1); //把数字转换成字符串 System.out.println(\"把整数转换成对应 的字符串：\"+Integer.toString(i)); //把整数转换成对应的进制形式 System.out.println(\"10的二进制：\"+ Integer.toBinaryString(10)); System.out.println(\"10的二进制：\"+ Integer.toBinaryString(10)); System.out.println(\"10的十六进制：\"+ Integer.toHexString(10)); //可以把字符串当成对应的进行数据帮你转换 String data = \"10\"; int a = Integer.parseInt(data, 2); System.out.println(\"a=\"+a); //集合： 集合是可以存储任意对象类型数据的容器。 ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); //自动装箱： 自动把java的基本数据类型数据转换成对象类型数据。 int temp = 10; //基本数据类型 Integer b =temp; //把a存储的值赋予给b变量。 //自动拆箱： 把引用类型的数据转换成基本类型的数据 Integer c = new Integer(13); int d = c; // System.out.println(d); //引用的数据类型 Integer e = 127; Integer f = 127; System.out.println(\"同一个对象吗？\"+(e==f)); // ture &#125; &#125; 注意： Integer类内部维护 了缓冲数组，该缓冲数组存储的-128~127 这些数据在一个数组中。如果你获取的数据是落入到这个范围之内的，那么就直接从该缓冲区中获取对应的数据。【Java8】 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 java123456789101112131415public class integer &#123; public static void main(String[] args) &#123; Integer a = new Integer(111); Integer b = new Integer(111); Integer c = Integer.valueOf(111); Integer d = Integer.valueOf(111); System.out.println(a == b); System.out.println(c == d); &#125;&#125; 结果： false true new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 看下面的例子： java1234567891011121314151617181920/** * @author Hongliang Zhu * @create 2020-01-28 11:38 */public class integer &#123; public static void main(String[] args) &#123; Integer a = new Integer(160); Integer b = new Integer(160); Integer c = Integer.valueOf(160); Integer d = Integer.valueOf(160); System.out.println(a == b); System.out.println(c == d); &#125;&#125; 结果为： false false 因为160超过了缓存的范围（-128-127），所以都是不同的对象， valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 如果不在缓存池中，则会new一个Integer对象。 java12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 看源码： java123456789101112131415161718192021222324252627282930313233 private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; ​ 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。 参考 [https://cyc2018.github.io/CS-Notes/#/notes/Java 基础](https://cyc2018.github.io/CS-Notes/#/notes/Java 基础) https://blog.csdn.net/Castile_zhu/article/details/78822267","categories":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://castile.github.io/tags/Java/"},{"name":"java基础","slug":"java基础","permalink":"https://castile.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"leetcode-684-冗余连接","slug":"leetcode-684-冗余连接","date":"2020-01-27T03:17:36.000Z","updated":"2020-01-27T03:24:39.172Z","comments":true,"path":"2020/01/27/leetcode-684-冗余连接/","link":"","permalink":"https://castile.github.io/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"描述 Leetcode684:RedundantConnection 冗余连接①： 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例 1： 输入: [[1,2], [1,3], [2,3]] 输出: [2,3] 解释: 给定的无向图为: 1 / 2 - 3 示例 2： 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 解释: 给定的无向图为: 5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 链接：https://leetcode-cn.com/problems/redundant-connection 分析 并查集的应用： 直接看代码，一次AC 代码 java123456789101112131415161718192021222324252627282930313233343536373839import java.util.Arrays;/** * @author Hongliang Zhu * @create 2020-01-27 10:17 *//*Leetcode684:RedundantConnection 冗余连接① */public class leetcode684_RedundantConnection &#123; public static int[] findRedundantConnection(int[][] edges) &#123; if(edges == null || edges.length == 0) return null; int n = edges.length; System.out.println(n); UF uf = new UF(n+1); for(int[] edge: edges)&#123; if(!uf.isSameSet(edge[0], edge[1]))&#123; uf.union(edge[0], edge[1]); &#125;else&#123; return edge; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; int [][]edges = &#123;&#123; 1,2 &#125;,&#123;1,3&#125;,&#123; 2,3&#125;&#125;; int []res = findRedundantConnection(edges); System.out.println(Arrays.toString(res)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"}]},{"title":"leetcode-130-被围绕的区域","slug":"leetcode-130-被围绕的区域","date":"2020-01-26T08:20:36.000Z","updated":"2020-01-26T13:02:02.122Z","comments":true,"path":"2020/01/26/leetcode-130-被围绕的区域/","link":"","permalink":"https://castile.github.io/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"描述 Leetcode-130： 被围绕的区域 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 链接：https://leetcode-cn.com/problems/surrounded-regions 分析 dfs搜索：将边界上的‘O’及其连通的先设置成‘#’标识，这些是不会被填充的，等搜索完毕之后再将这些标志换回‘O’。而在里面的‘O’就是被包围的区域，通过双层循环将里面的’O‘替换成’X‘即可。 并查集：并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。 并查集代码：UF java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author Hongliang Zhu * @create 2020-01-25 21:25 */// 并查集 UFpublic class UF &#123; private int count = 0; // 连通分量 private int[] parent; // 新增一个数组记录树的“重量” private int[] size; // 构造 public UF(int n)&#123; // n个元素 this.count = n; size = new int[n]; parent = new int[n]; // 一开始每一个节点自成一个集合，都不连通 for (int i = 0; i &lt; n; i++)&#123; parent[i] = i; // 自己的父节点指向自己 size[i] = 1; // 每隔几何只有自身一个元素 &#125; &#125; public int find(int x)&#123; int root = parent[x]; while (parent[x] != x)&#123; // 路径压缩 x = parent[x]; &#125; return x; &#125; public boolean isSameSet(int a, int b)&#123; return find(a) == find(b); &#125; public int count()&#123; return count; &#125; public void union(int a, int b)&#123; int rootA = find(a); int rootB = find(b); if(rootA == rootB)&#123; return; // 同一个集合不能合并 &#125;else&#123; if(size[rootA] &gt; size[rootB])&#123; parent[rootB] = rootA; size[rootA] += size[rootB]; &#125;else &#123; parent[rootA] = rootB; size[rootB] += size[rootA]; &#125; &#125; count--; // 连通分量个数减一 &#125;&#125; 可以把那些不需要被替换的 O 看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫 dummy****，这些 O 和 dummy 互相连通，而那些需要被替换的 O 与 dummy 不连通。 如下图: ​ 首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。 ​ 这个很简单，二维坐标 (x,y) 可以转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数）。敲黑板，这是将二维坐标映射到一维的常用技巧。 ​ 其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 [0.. m*n-1] 都是棋盘内坐标的一维映射，那就让这个虚拟的 dummy 节点占据索引 m * n 好了。 ​ 我们的思路是把所有边界上的 O看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类 和边界上的 O在一个连通区域内的。这些 O 我们保留。 不和边界上的O 在一个连通区域内的。这些 O 就是被包围的，替换。 代码 dfs版本 java123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; public void solve(char[][] board) &#123; if(board == null || board.length == 0) return; int m = board.length; int n = board[0].length; // 边缘搜索 for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if((i == 0 || j == 0 || i == m-1 || j == n-1) &amp;&amp; (board[i][j] == 'O'))&#123; dfs(board, i, j); &#125; &#125; &#125; // for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(board[i][j] == 'O')&#123; board[i][j] = 'X'; &#125; if(board[i][j] == '#')&#123; board[i][j] = 'O'; &#125; &#125; &#125; &#125; public void dfs(char[][] board, int i, int j)&#123; if(i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] != 'O') return; board[i][j] = '#'; for(int[] d: directions)&#123; dfs(board, i+d[0], d[1]+j); &#125; &#125;&#125; 并查集 java12345678910111213141516171819202122232425262728293031323334353637383940// 使用并查集解决public static void solveUF(char[][] board) &#123; if(board==null || board.length == 0) return; int m = board.length; int n = board[0].length; // 边界上的‘O’的根节点都是dummy UF uf = new UF(n * m + 1);// 增加一个存储dummy节点 int dummy = m * n; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(board[i][j] == 'O')&#123; // 目标 if(i == 0 || j == 0 || i == m -1 || j == n -1) &#123; // 如果是边界上的'O'， 与dummy合并 uf.union(i*n+j, dummy); &#125;else&#123; // 里面的 // 方向数组 d 是上下左右搜索的常用手法 int[][] d = new int[][]&#123;&#123;1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;; // 将此 O 与上下左右的 O 连通 for (int k = 0; k &lt; 4; k++) &#123; int x = i + d[k][0]; int y = j + d[k][1]; if (board[x][y] == 'O') uf.union(x * n + y, i * n + j); &#125; &#125; &#125; &#125; &#125; for (int i = 1; i &lt; m-1; i++)&#123; for( int j = 1; j &lt; n-1; j++)&#123; if(!uf.isSameSet(i*n+j, dummy))&#123; board[i][j] = 'X'; &#125; &#125; &#125; &#125; 参考： https://cyc2018.github.io/CS-Notes https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong#yi-dfs-de-ti-dai-fang-an","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dfs","slug":"dfs","permalink":"https://castile.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"https://castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"搜索","slug":"搜索","permalink":"https://castile.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"leetcode-1-两数之和","slug":"leetcode-1-两数之和","date":"2020-01-23T13:54:23.000Z","updated":"2020-01-23T14:15:03.787Z","comments":true,"path":"2020/01/23/leetcode-1-两数之和/","link":"","permalink":"https://castile.github.io/2020/01/23/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 [x] 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 链接：https://leetcode-cn.com/problems/two-sum 分析 暴力方法： 直接两层循环，时间复杂度较高：O(n2) 哈希方法：使用哈希表可以实现O(1)级别的存取。存储每个数对应的下标，复杂度 O(n) 参考： HashMap的时间复杂度O(1)的思考： ​ 原文链接：https://blog.csdn.net/donggua3694857/article/details/64127131 Java代码实现 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package Arrays;import java.util.HashMap;/** * @author Hongliang Zhu * @create 2020-01-23 21:39 */public class leetcode_1_twoSum &#123; // 暴力法 public static int[] twoSum(int[] nums, int target) &#123; int[] a = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; a[0] = i; a[1] = j; break; &#125; &#125; &#125; return a; &#125; // 哈希 public static int[] twoSum1(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; mymap = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; mymap.put(nums[i], i); &#125; for(int i = 0; i &lt; nums.length; i++)&#123; int t = target - nums[i]; if(mymap.containsKey(t) &amp;&amp; mymap.get(t) != i )&#123;// 注意后面这个条件，题目要求 return new int[] &#123;i,mymap.get(t)&#125;; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; int[] nums = &#123; 2,11,15, 7&#125;; int target = 9; int []result = twoSum1(nums, target); for (int i = 0; i &lt; result.length; i++) &#123; System.out.println(result[i]); &#125; &#125;&#125; 参考HashMap： https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486169&amp;idx=2&amp;sn=9818c995d51a19cd4a40c2605bdcfa5d&amp;chksm=ebd74bd8dca0c2cefe86f54bcdd7f799ceda0a14deb72a4fcec7efa29fc3deffbc6e80d8a90f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575479594341&amp;sharer_shareid=2d7d0e474d11d42bad66b1f70e2c85ff&amp;key=688085f24308deb8e963b43a687ea8ed3be23533e2ae4e751f02a336bb46979d39e6c74e731daa5fc22d9e719338c7f0f98152a12a38beef1d0023e2939dd0eda93264a9d032b8cc555448c332453c25&amp;ascene=1&amp;uin=MjA3NDA5MzU4MQ==&amp;devicetype=Windows 10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=A5ZIZKTn0EuksyOXwEiV%2BEk=&amp;pass_ticket=Nb/JBXAYTcQup5FBKcfsQy6kFv5X2eJwQ333U4h1UYJmrnawwezuSj8nX18XzQ8s","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"简单","slug":"简单","permalink":"https://castile.github.io/tags/%E7%AE%80%E5%8D%95/"},{"name":"数组","slug":"数组","permalink":"https://castile.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"记2020年1月22日","slug":"记2020年1月22日","date":"2020-01-22T12:37:27.000Z","updated":"2020-01-22T12:50:08.604Z","comments":true,"path":"2020/01/22/记2020年1月22日/","link":"","permalink":"https://castile.github.io/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/","excerpt":"","text":"2020年1月22日， 回老家的第二天，去了趟外婆家，吃撑了。 ​ 这鱼的力气真大，在我手中挣脱好几次了，费了九牛二虎之力才把他弄回家！！！ ​ 最近不知为啥，一吃饭，附近的各种野猫和其他人家的小狗就过来了…挺可爱的 最几天肺炎很严重啊！担心。 再见。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://castile.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://castile.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"日记","slug":"日记","permalink":"https://castile.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"leetcode-128-最长连续序列","slug":"leetcode-128-LongestConsecutiveSequence","date":"2020-01-22T10:15:19.000Z","updated":"2020-01-23T14:15:48.945Z","comments":true,"path":"2020/01/22/leetcode-128-LongestConsecutiveSequence/","link":"","permalink":"https://castile.github.io/2020/01/22/leetcode-128-LongestConsecutiveSequence/","excerpt":"","text":"描述 LeetCode128: 最长连续序列longest-consecutive-sequence 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 【困难】 示例: 输入: [100, 4, 200, 1, 3, 2] 输出: 4 解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 链接：https://leetcode-cn.com/problems/longest-consecutive-sequence 分析 ​ 如果允许O(nlogn)的复杂度，那么可以先排序，可是本题要求 O(n) 。 由于序列里的元素是无序的，又要求 O(n) ，首先要想到用哈希表。 用一个哈希表存储所有出现过的元素，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记 录下最长的长度。 Java代码实现 java1234567891011121314151617181920212223242526272829303132333435363738394041424344package Arrays;import java.util.HashSet;/** * @author Hongliang Zhu * @create 2020-01-22 18:15 *//*给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。 */public class leetcode128_LongestConsecutiveSequence &#123; public static int longestConsecutive(int[] nums) &#123; HashSet&lt;Integer&gt; myset = new HashSet&lt;&gt;(); for(int i: nums)&#123; myset.add(i); &#125; int longest = 0; for(int i: nums) &#123; int len = 1; for(int j = i+1; myset.contains(j); j++)&#123; myset.remove(j); len++; &#125; for (int j = i - 1; myset.contains(j); j--)&#123; myset.remove(j); len++; &#125; longest = Math.max(longest, len); &#125; return longest; &#125; public static void main(String[] args) &#123; int []nums = &#123;100, 4, 200, 1, 3, 2&#125;; int len = longestConsecutive(nums); System.out.println(len); &#125;&#125; 输出4 时间复杂度为O(n) ， 空间复杂度O(n) Leetcode官方： java12345678910111213141516171819202122232425262728293031class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int longestStreak = 1; int currentStreak = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[i-1]) &#123; if (nums[i] == nums[i-1]+1) &#123; currentStreak += 1; &#125; else &#123; longestStreak = Math.max(longestStreak, currentStreak); currentStreak = 1; &#125; &#125; &#125; return Math.max(longestStreak, currentStreak); &#125;&#125;作者：LeetCode链接：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://castile.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希","slug":"哈希","permalink":"https://castile.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"困难","slug":"困难","permalink":"https://castile.github.io/tags/%E5%9B%B0%E9%9A%BE/"}]},{"title":"leetcode-80-删除排序数组的重复项2","slug":"leetcode-80-删除排序数组的重复项2","date":"2020-01-22T08:47:45.000Z","updated":"2020-01-22T10:13:33.534Z","comments":true,"path":"2020/01/22/leetcode-80-删除排序数组的重复项2/","link":"","permalink":"https://castile.github.io/2020/01/22/leetcode-80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B92/","excerpt":"","text":"描述 leetcode-80-删除排序数组的重复项2： 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii 相似题目： https:/Castile.github.io/2020/01/21/leetcode26-删除排序数组的重复项/ tag：双指针思想 示例 1: 给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。 分析 ​ 覆盖多余的重复项。由于题目要求原地操作，设置两个指针，一个为快指针，用来遍历整个数组，一个慢指针，用来记录数组的长度以及覆盖数组的位置下标。题目要求每个元素最多出现两次，则应该引入一个计数变量，记录元素出现的次数。 ​ 特别地，题目给的数组为已经排好序的数组，如果未排序，则需要引入一个hashmap来记录出现次数。 ​ 从下标1开始遍历，nums[i-1] ?= nums[i] ：如果相等，则更新 时间复杂度O(n)， 空间复杂度O(1) Java代码实现 java12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Hongliang Zhu * @create 2020-01-22 10:07 */public class leetcode_80_remove_duplicates_from_sorted_array_ii &#123; public static int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int p = 1; int c = 1; // 计数 for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] == nums[i-1])&#123; c++; &#125;else &#123; c = 1; //复位 &#125; if( c &lt;= 2) &#123; nums[p] = nums[i]; p++; &#125; &#125; return p; &#125; public static void main(String[] args) &#123; int []nums = &#123;0,0,1,1,1,1,2,3,3&#125;; int len = removeDuplicates(nums); System.out.println(len); for (int i = 0; i &lt; len; i++) &#123; System.out.println(nums[i]); &#125; &#125;&#125; 输出： c#1270,0,1,1,2,3,3, 另外： java1234567891011121314public static int removeDuplicates2(int[] nums) &#123; if (nums.length &lt;= 2)&#123; return nums.length; &#125; int index = 2; for(int i = 2; i &lt; nums.length; i++)&#123; if(nums[index-2] != nums[i])&#123; nums[index++] = nums[i]; &#125; &#125; return index;&#125; 扩展性，例如将上面的数字2 改为 3 ， 就变成了允许重复最多3次。 **相似题目： https:/Castile.github.io/2020/01/21/leetcode26-删除排序数组的重复项/","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://castile.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"中等","slug":"中等","permalink":"https://castile.github.io/tags/%E4%B8%AD%E7%AD%89/"},{"name":"双指针","slug":"双指针","permalink":"https://castile.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"leetcode26-删除排序数组的重复项","slug":"leetcode26-删除排序数组的重复项","date":"2020-01-21T15:43:12.000Z","updated":"2020-01-22T12:36:15.400Z","comments":true,"path":"2020/01/21/leetcode26-删除排序数组的重复项/","link":"","permalink":"https://castile.github.io/2020/01/21/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 思路 可以采用快慢指针，即双指针思路，这种方法在线性表查重，判断环上用的比较多。 ​ 数组完成排序后，我们可以放置两个指针 p 和q，其中p是慢指针，而 q 是快指针。只要 nums[p] = nums[q]，我们就增加 q以跳过重复项。当我们遇到 nums[p] ≠ nums[q] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[q]）的值复制到 nums[p+1]。然后递增 p，接着我们将再次重复相同的过程，直到q到达数组的末尾为止。 ​ 时间复杂度O(n), 空间复杂度O(1)： java123456789101112131415161718192021class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0)&#123; return 0; &#125; int p = 0; int q = 1; while(q &lt; nums.length)&#123; if(nums[p] == nums[q])&#123; q++; &#125;else&#123; nums[p+1] = nums[q]; p++; &#125; &#125; return p + 1 ; &#125;&#125; 相关： https:/Castile.github.io/2020/01/22/leetcode-80-删除排序数组的重复项2/","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://castile.github.io/categories/Algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"https://castile.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"最长公共子序列问题","slug":"最长公共子序列问题","date":"2020-01-20T06:32:12.000Z","updated":"2020-01-20T07:07:25.347Z","comments":true,"path":"2020/01/20/最长公共子序列问题/","link":"","permalink":"https://castile.github.io/2020/01/20/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/","excerpt":"","text":"c++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;/* 最长公共子序列问题 2019-12-15 12:48:14*/char x[100];char y[100];int dp[100][100];int b[100][100];int LCS(char x[], char y[],int m, int n)&#123; // 初始化 for (int i = 0; i &lt;= m; i++) // 初始化第一列 &#123; dp[i][0] = 0; &#125; for (int i = 0; i &lt;= n; i++) &#123; dp[0][i] = 0; // 初始化第一行 &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (x[i] == y[j]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; b[i][j] = 1; &#125; else if (dp[i - 1][j] &gt;= dp[i][j - 1]) &#123; dp[i][j] = dp[i - 1][j]; b[i][j] = 2; &#125; else &#123; dp[i][j] = dp[i][j - 1]; b[i][j] = 3; &#125; &#125; &#125; return dp[m][n];&#125;// 根据b矩阵得出最长公共子序列stack&lt;char&gt; s;void getLCS(int i, int j)&#123; // basecase if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; if (b[i][j] == 1) &#123; s.push(x[i]); getLCS(i - 1, j - 1); &#125; if (b[i][j] == 2) &#123; getLCS(i - 1, j); &#125; if (b[i][j] == 3) &#123; getLCS(i, j - 1); &#125; &#125; &#125;int main()&#123; int m, n = 0; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; y[i]; &#125; cout &lt;&lt; LCS(x, y, m, n) &lt;&lt; endl; //dp矩阵 for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; cout &lt;&lt; dp[i][j] &lt;&lt; \"\\t\"; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; getLCS(m, n); //打印最长公共子序列 while (!s.empty()) &#123; cout &lt;&lt; s.top() &lt;&lt; endl; s.pop(); &#125; system(\"pause\"); return 0;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://castile.github.io/tags/%E7%AE%97%E6%B3%95/"}]}]}
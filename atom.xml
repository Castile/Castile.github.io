<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Castile</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://castile.github.io/"/>
  <updated>2020-02-06T10:06:18.234Z</updated>
  <id>https://castile.github.io/</id>
  
  <author>
    <name>朱宏梁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-206-反转链表</title>
    <link href="https://castile.github.io/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://castile.github.io/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-06T09:39:44.000Z</published>
    <updated>2020-02-06T10:06:18.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h1><blockquote><p>leetcode206： 反转链表 【简单】</p><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a></p></blockquote><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ul><li><p>迭代： 如下图：</p><a href="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982171220.png" data-fancybox="group" data-caption="1580982171220" class="fancybox"><img alt="1580982171220" style="zoom:80%;" align="center" data-src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982171220.png" class="lazyload" title="1580982171220"></a></li></ul><a href="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982209880.png" data-fancybox="group" data-caption="1580982209880" class="fancybox"><img alt="1580982209880" style="zoom:80%;" align="center" data-src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982209880.png" class="lazyload" title="1580982209880"></a><p>​时间复杂度：O(n) 。 假设 <em>n</em> 是列表的长度，时间复杂度是 O(n)。</p><p>​空间复杂度：O(1)。</p><ol start="2"><li><p>递归</p><p>1、找到递归出口</p><p>2、确定返回值</p><p>3、分析单次递归需要做的事情</p><p>下面，我们来具体分析一下：</p><p>首先，找到递归出口，这个还是非常简单的，就是当前即将反转的节点为 null 或者是 反转链表 为 null 时（一轮递归其实就只有两个节点，后面会讲），说明已经全部反转完毕了，即递归出口；<br>其次，确定返回值，我们只需要返回反转链表的头结点即可；<br>最后，分析单次递归需要做的事情，递归其实每一轮做的事情都是一样的，我们不需要去重复考虑，这样反而会很乱，只需要考虑单轮递归需要做什么就可以了。在这里，我们就只有两个节点，一个是即将反转的节点元素，一个是已经反转完毕的链表头结点。 我们要做的一轮递归只是 将当前节点加入到反转链表中，仅此而已。<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/bang-zhu-da-jia-li-jie-di-gui-zuo-fa-by-jeromememo/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/solution/bang-zhu-da-jia-li-jie-di-gui-zuo-fa-by-jeromememo/</a></p></li></ol><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p><a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode206_ReverseLinkedList.java" target="_blank" rel="noopener">https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode206_ReverseLinkedList.java</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-06 17:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    反转单链表： 要求时间复杂度为O((n) ，空间复杂度为O(1)；</span></span><br><span class="line"><span class="comment">    Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment">    Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode206_ReverseLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">reverdeList_Recur</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> help(head, <span class="keyword">null</span>, head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">help</span><span class="params">(ListNode head, ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> pre;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">        <span class="keyword">return</span> help(head, pre, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优美递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseListRR</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = reverseListRR(head.next);</span><br><span class="line">        <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">        <span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">        <span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">        head.next.next = head; <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">        head.next  = <span class="keyword">null</span>; <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(p.val +<span class="string">"\t"</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode n1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode n2 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode n3 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode n4 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        head.next = n1;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line"></span><br><span class="line">        printLinkedList(head);</span><br><span class="line"></span><br><span class="line">        ListNode re = reverseListRR(head);</span><br><span class="line"></span><br><span class="line">        printLinkedList(re);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982603520.png" data-fancybox="group" data-caption="1580982603520" class="fancybox"><img alt="1580982603520" align="center" data-src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982603520.png" class="lazyload" title="1580982603520"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="递归" scheme="https://Castile.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="链表" scheme="https://Castile.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-119-杨辉三角2</title>
    <link href="https://castile.github.io/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/"/>
    <id>https://castile.github.io/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/</id>
    <published>2020-02-06T07:28:31.000Z</published>
    <updated>2020-02-06T08:26:20.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h1><blockquote><p>leetcode119： 杨辉三角2 【简单】</p><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><a href="/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/blog\source\_posts\leetcode-119-杨辉三角2\PascalTriangleAnimated2.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" data-src="/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/blog\source\_posts\leetcode-119-杨辉三角2\PascalTriangleAnimated2.gif" class="lazyload" title="img"></a><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure></div></blockquote><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li>这题和前一题一样，只不过返回特定层，同样的思路</li></ol>   <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rowIndex+<span class="number">2</span>][rowIndex+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(rowIndex+<span class="number">1</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= rowIndex+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                list.add(calc(dp, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.get(rowIndex);  <span class="comment">// 注意返回的是指定层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)&#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j] = calc(dp, i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(dp, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li><p>这题和<a href="%5Bhttps:/Castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/%5D(%5Bhttps:/Castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/)">杨辉三角1</a>的题目差不多，118题需要保存所有的，但是这题只需要返回指定层，因为当前层的值只依赖于上一层的值，故使用一个list来保存上一层的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || i == j)&#123;</span><br><span class="line">                    cur.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.add(pre.get(j - <span class="number">1</span>) + pre.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></li><li><p>基于2可以继续优化：以把 pre 的 List 省去。这样的话，cur每次不去新建 List，而是把cur当作pre。</p><p>又因为更新当前 <code>j</code> 的时候，就把之前<code>j</code>的信息覆盖掉了。而更新 <code>j + 1</code> 的时候又需要之前j的信息，所以在更新前，我们需要一个变量把之前<code>j</code>的信息保存起来。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">       List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       cur.add(<span class="number">1</span>); <span class="comment">// j == 0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> tmp = cur.get(j);</span><br><span class="line">               cur.set(j, pre + cur.get(j));</span><br><span class="line">               pre = tmp;</span><br><span class="line">           &#125;</span><br><span class="line">           cur.add(<span class="number">1</span>);  <span class="comment">// j == i</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></li><li><p>除了上边优化的思路，还有一种想法，那就是倒着进行，这样就不会存在覆盖的情况了。因为更新完j的信息后，虽然把<code>j</code>之前的信息覆盖掉了。但是下一次我们更新的是<code>j - 1</code>，需要的是<code>j - 1</code>和<code>j - 2</code> 的信息，<code>j</code>信息覆盖就不会造成影响了。</p></li></ol><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p><a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode119_PascalTriangle2.java" target="_blank" rel="noopener">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode119_PascalTriangle2.java</a></p><p>相似题目：<a href="https:/Castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/">杨辉三角</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="递归" scheme="https://Castile.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="dp" scheme="https://Castile.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-118-杨辉三角1</title>
    <link href="https://castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/"/>
    <id>https://castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/</id>
    <published>2020-02-06T07:28:12.000Z</published>
    <updated>2020-02-06T08:26:32.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h1><blockquote><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><p>输入: 5<br>输出:<br>[<br>[1],<br>[1,1],<br>[1,2,1],<br>[1,3,3,1],<br>[1,4,6,4,1]<br>]</p><p>链接：<a href="https://leetcode-cn.com/problems/pascals-triangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pascals-triangle</a></p></blockquote> <a href="/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/PascalTriangleAnimated2.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/PascalTriangleAnimated2.gif" class="lazyload" title="img"></a> <h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li><p>暴力递归：basecase：可以看到，每行的最左边和最右边的数字是1。因此，我们可以将基本情况定义如下:  <code>f(i, j)=1 where j=1 or j==i</code></p><p>递推关系：</p><p>​首先，我们定义一个函数 <code>f(i,j)</code>它将会返回帕斯卡三角形<code>第 i 行</code>、<code>第 j 列</code>的数字。</p><p>我们可以用下面的公式来表示这一递推关系：<code>f(i,j)=f(i−1,j−1)+f(i−1,j)</code></p></li><li><p>动态规划：因为暴力递归还有很多值会重复计算，所以使用一个数组保存已经计算过的值。</p></li></ol><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>源码：  <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode118_PascalTriangle.java" target="_blank" rel="noopener">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode118_PascalTriangle.java</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归： 但是会超时</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> triangle;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= numRows; i++)&#123;</span><br><span class="line">           List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">               list.add(calc(i, j));</span><br><span class="line">           &#125;</span><br><span class="line">           triangle.add(list);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> triangle;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> calc(i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(i - <span class="number">1</span>, j);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>动态规划：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numRows+<span class="number">1</span>][numRows+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> triangle;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= numRows; i++)&#123;</span><br><span class="line">                List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                    list.add(calc(dp, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">                triangle.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">            dp[i][j] = calc(dp, i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(dp, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>相似题目：  <a href="https://castile.github.io/Castile.github.io/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/">leetcode-119-杨辉三角2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ALgorithm" scheme="https://Castile.github.io/categories/ALgorithm/"/>
    
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="递归" scheme="https://Castile.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="dp" scheme="https://Castile.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>CosNet:基于协同注意孪生网络的无监督视频目标分割</title>
    <link href="https://castile.github.io/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/"/>
    <id>https://castile.github.io/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/</id>
    <published>2020-02-05T13:42:03.000Z</published>
    <updated>2020-02-05T15:17:54.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="cvpr2019cosnetsee-more-know-more-unsupervised-video-object-segmentation-with-co-attention-siamese-networks"><a class="markdownIt-Anchor" href="#cvpr2019cosnetsee-more-know-more-unsupervised-video-object-segmentation-with-co-attention-siamese-networks"></a> 【CVPR2019】CosNet：See More, Know More: Unsupervised Video Object Segmentation with Co-Attention Siamese Networks</h1><h2 id="基于协同注意孪生网络的无监督视频目标分割"><a class="markdownIt-Anchor" href="#基于协同注意孪生网络的无监督视频目标分割"></a> 基于协同注意孪生网络的无监督视频目标分割</h2><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>​         以往的无监督视频目标分割基于深度学习的方法仅仅考虑短期时域信息，没有考虑整个视频的全局信息，而且并没有有效利用视频内容的内在相关信息 ，**Co-attention Siamese Network(CosNet)**提出了一个统一的端到端的无监督视频目标分割网络。</p><p>​CosNet将UVOS作为co-attention的过程。一个co-attention模块学习去显示编码帧与帧之间的关系，使CosNet可以获取频繁相关的区域，进而可以帮助发现前景目标来进行分割。具体的，在训练阶段，co-attention过程能够分解为同一视频中任意帧对之间的相关性学习，在测试的时候，CosNet使用全局视角推断前景目标，也就是说利用测试帧与多个相关的帧的co-attention信息来判断主要的前景目标。CosNet的网络结构如下图所示。这是无监督视频目标分割最好的模型，在Davis2016数据集上的J-means达到了80.5的分数。</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910682924.png" data-fancybox="group" data-caption="1580910682924" class="fancybox"><img alt="1580910682924" style="zoom:80%;" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910682924.png" class="lazyload" title="1580910682924"></a><p>​CosNet认为无监督视频目标分割下的主要目标拥有以下特点：</p><blockquote><p>1)单帧可区分(本地显著性)；</p><p>2)在整个视频序列中频繁出现的目标(全局一致性)。</p></blockquote><p>​这两个特点对于区分视频序列中的主要目标的非常重要的。通过考虑视频的全局信息，可以锁定主要目标，进而进行分割。</p><h1 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h1><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" data-fancybox="group" data-caption="1580910735819" class="fancybox"><img alt="1580910735819" style="zoom:80%;" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" class="lazyload" title="1580910735819"></a><p>​输入是图片对，图片对可以从视频中随机取得。两帧图片经过基网络（DeeplabV3），也称编码网络（Encoder）， 将两帧编码成嵌入特征，然后协同注意力模块会计算两帧的相似性，即两帧之间的相关注意力特征。最后输入到分割模块得到最后的分割结果。</p><h1 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1><h2 id="co-attention-mechanisms-in-cosnet"><a class="markdownIt-Anchor" href="#co-attention-mechanisms-in-cosnet"></a> Co-attention Mechanisms in COSNet</h2><p>作者提出了三种协同注意力机制，分别为Vanilla co-attention， Symmetric co-attention，Channel-wise co-attention。一个注意力模块这显式地编码两帧之间的相关性，这样可以使得COsNet学习到频繁相关的区域。</p><h3 id="vanilla-co-attention"><a class="markdownIt-Anchor" href="#vanilla-co-attention"></a> Vanilla co-attention</h3><p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911492126.png" data-fancybox="group" data-caption="1580911492126" class="fancybox"><img alt="1580911492126" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911492126.png" class="lazyload" title="1580911492126"></a></p><p>S 是两帧之间的afﬁnity matrix（相似矩阵），Va和Vb的shape是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo>∗</mo><mi>H</mi><mo>∗</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">W * H  * C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>Va的每一列表示特征向量，W是一个方阵</p><p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911687054.png" data-fancybox="group" data-caption="1580911687054" class="fancybox"><img alt="1580911687054" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911687054.png" class="lazyload" title="1580911687054"></a></p><p>所以S又可以写成：</p><div align="center"> <p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911733141.png" data-fancybox="group" data-caption="1580911733141" class="fancybox"><img alt="1580911733141" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911733141.png" class="lazyload" title="1580911733141"></a></p></div><p>通过上面公式，首先对每一帧的特征表示进行线性变换，然后计算它们之间的距离 。</p><h3 id="symmetric-co-attention"><a class="markdownIt-Anchor" href="#symmetric-co-attention"></a> Symmetric co-attention</h3><p>如果对权重矩阵进行约束，令权重矩阵为一个对称矩阵。则投影矩阵P就变成一个正交矩阵<a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/blog\source\_posts\CosNet-基于协同注意孪生网络的无监督视频目标分割\1580912078801.png" data-fancybox="group" data-caption="1580912078801" class="fancybox"><img alt="1580912078801" style="zoom: 80%;" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/blog\source\_posts\CosNet-基于协同注意孪生网络的无监督视频目标分割\1580912078801.png" class="lazyload" title="1580912078801"></a></p><p>I是一个C * C的单位阵。则Symmetric co-attention的计算公式为：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912157546.png" data-fancybox="group" data-caption="1580912157546" class="fancybox"><img alt="1580912157546" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912157546.png" class="lazyload" title="1580912157546"></a><p>上述公式表明将嵌入向量Va和Vb的特征投影到正交公共空间中，并保持它们的范数。这一特性可以消除不同通道之间的相关性和提高网络的泛化能力。</p><h2 id="channel-wise-co-attention"><a class="markdownIt-Anchor" href="#channel-wise-co-attention"></a> Channel-wise co-attention</h2><p>将投影矩阵P简单地表示成单位矩阵 I （也就是没有进行空间的转换），然后权重矩阵W变成对角矩阵，在这种情况下，W（也就是D）可以分为两个对角矩阵Da和Db， 因此，公式3可以重新写成一下形式，也就是Channel-wise co-attention：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912721357.png" data-fancybox="group" data-caption="1580912721357" class="fancybox"><img alt="1580912721357" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912721357.png" class="lazyload" title="1580912721357"></a><p>这个操作相当于在计算相似度之前对Va和Vb应用一个信道权值, 这有助于缓解通道冗余 .</p><h1 id="协同注意力操作"><a class="markdownIt-Anchor" href="#协同注意力操作"></a> 协同注意力操作</h1><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912845406.png" data-fancybox="group" data-caption="1580912845406" class="fancybox"><img alt="1580912845406" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912845406.png" class="lazyload" title="1580912845406"></a><p>协同注意力操作如上图所示，在获取了相似度矩阵S之后，对S的行向量和列向量进行SoftMax操作：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912943618.png" data-fancybox="group" data-caption="1580912943618" class="fancybox"><img alt="1580912943618" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912943618.png" class="lazyload" title="1580912943618"></a><p>结合上图：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913044245.png" data-fancybox="group" data-caption="1580913044245" class="fancybox"><img alt="1580913044245" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913044245.png" class="lazyload" title="1580913044245"></a><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" data-fancybox="group" data-caption="1580910735819" class="fancybox"><img alt="1580910735819" style="zoom:80%;" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" class="lazyload" title="1580910735819"></a><p>在网络中的协同注意力模块还有一个Gated co-attention操作， 考虑到输入对、遮挡和背景噪声之间潜在的外观变化，最好对来自不同输入帧的信息进行加权，而不是平均处理所有的共同注意信息。</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913182677.png" data-fancybox="group" data-caption="1580913182677" class="fancybox"><img alt="1580913182677" style="zoom:150%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913182677.png" class="lazyload" title="1580913182677"></a> $$\sigma是一个sigmoid激活函数，w_f和b_f表示卷积核和偏置参数。$$<p>计算完gate的置信度之后，注意力Z表示为：<br><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913526624.png" data-fancybox="group" data-caption="1580913526624" class="fancybox"><img alt="1580913526624" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913526624.png" class="lazyload" title="1580913526624"></a></p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913588288.png" data-fancybox="group" data-caption="1580913588288" class="fancybox"><img alt="1580913588288" style="zoom:80%;" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913588288.png" class="lazyload" title="1580913588288"></a><hr><h1 id="cosnet-整体架构"><a class="markdownIt-Anchor" href="#cosnet-整体架构"></a> CosNet 整体架构</h1><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913733433.png" data-fancybox="group" data-caption="1580913733433" class="fancybox"><img alt="1580913733433" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913733433.png" class="lazyload" title="1580913733433"></a><p>CosNet是一个孪生网络，由三个级联的部分，一个基于DeepLabV3的特征嵌入模块，一个协同注意力模块以及分割模块。</p><h2 id="训练阶段"><a class="markdownIt-Anchor" href="#训练阶段"></a> 训练阶段</h2><p>​上文说到，视频中的主要对象（即要分割的对象）有两个基本属性:(i)帧内可分辨性，(ii)帧间一致性。为了区分前景目标和背景(属性(i))，我们利用现有的显著性目标分割数据集DUTS和MSRA 10K来训练我们的backbone特征嵌入模块。同时，为了确保COSNet能够捕获主要视频对象的全局帧间相干性(property (ii))，我们使用视频分割数据训练整个COSNet，其中co-attention模块在捕获视频帧之间的相关性方面起着关键作用。具体来说，我们在一个视频序列中随机选取两帧来建立训练对。值得一提的是，与以往的基于循环神经网络的UVOS模型只需要连续帧相比，这种操作自然有效地扩充了训练数据, 即数据增强。</p><p>​通过这种方式，COSNet可以交替使用静态图像数据和动态视频数据进行训练。在使用图像数据时，我们只训练了特征嵌入模块，其中增加了1×1的sigmoid激活卷积层，生成中间分割的sideoutput。视频数据用于训练整个COSNet，包括特征嵌入模块、协同注意模块和分割模块。利用加权二叉熵损失训练网络:</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914232679.png" data-fancybox="group" data-caption="1580914232679" class="fancybox"><img alt="1580914232679" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914232679.png" class="lazyload" title="1580914232679"></a><p>其实训练阶段是<strong>完全监督</strong>的，因为使用到了groundtruth。</p><h2 id="测试阶段"><a class="markdownIt-Anchor" href="#测试阶段"></a> 测试阶段</h2><p>​训练完成之后，使用模型在其他没有见过的视频序列中进行测试。给定一个测试视频序列，我们可以将每个要分割的帧，以及从同一视频中采样的一个参考帧，依次输入到COSNet中，通过逐帧的操作，我们可以得到所有的分割结果。</p><p>​然而，在这样一个简单的策略下，分割结果仍然含有相当大的噪声，因为视频中丰富的全局相关信息并没有得到充分的挖掘。因此，在测试阶段包含更多的是推导帧常重要的：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914483240.png" data-fancybox="group" data-caption="1580914483240" class="fancybox"><img alt="1580914483240" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914483240.png" class="lazyload" title="1580914483240"></a><p>将一组N个不同的参考帧(从同一视频中均匀采样)输入推理分支，并对所有预测进行平均。</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914542254.png" data-fancybox="group" data-caption="1580914542254" class="fancybox"><img alt="1580914542254" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914542254.png" class="lazyload" title="1580914542254"></a><h1 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h1><p>DAVIS-2016数据集：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914796880.png" data-fancybox="group" data-caption="1580914796880" class="fancybox"><img alt="1580914796880" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914796880.png" class="lazyload" title="1580914796880"></a><p>FBMS数据集：<br><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914854214.png" data-fancybox="group" data-caption="1580914854214" class="fancybox"><img alt="1580914854214" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914854214.png" class="lazyload" title="1580914854214"></a></p><p>YoutubeObjects  数据集：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914901876.png" data-fancybox="group" data-caption="1580914901876" class="fancybox"><img alt="1580914901876" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914901876.png" class="lazyload" title="1580914901876"></a><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><ol><li><p>协同注意力机制基于全局的视角进行推断前景和背景的分割，效果显著。</p></li><li><p>在测试时，平均多个帧的的注意力更有效</p></li><li><p>为了研究最终预测在测试阶段的帧选择策略，我们进一步使用不同的采样方法进行了一系列的实验。具体采用全局随机抽样、全局均匀抽样和局部连续抽样。从表1中可以看出，两种全局水平的采样策略都能获得近似的性能，但都优于局部采样方法。同时，基于局部采样的结果仍然优于从骨干网获得的结果。整体比较进一步证明了合并的重要性 。</p></li><li><p>关于参考帧数的选择，如表：</p><a href="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580915369748.png" data-fancybox="group" data-caption="1580915369748" class="fancybox"><img alt="1580915369748" style="zoom:80%;" align="center" data-src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580915369748.png" class="lazyload" title="1580915369748"></a><p>当N = 0时，这意味着没有共同注意分割。当N从0变为1时，可以看到一个很大的性能改进 。N从2变化到5，定量结果显示性能有所提高。当我们进一步增加N时，最终的性能没有明显的变化。实验中使用的N=5。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="论文阅读" scheme="https://Castile.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="UVOS" scheme="https://Castile.github.io/tags/UVOS/"/>
    
      <category term="papers" scheme="https://Castile.github.io/tags/papers/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-344-反转字符串</title>
    <link href="https://castile.github.io/2020/02/03/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://castile.github.io/2020/02/03/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-02-03T08:53:27.000Z</published>
    <updated>2020-02-03T09:10:10.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h1><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p></blockquote><blockquote><p>示例 1：</p><p>输入：[“h”,“e”,“l”,“l”,“o”]<br>输出：[“o”,“l”,“l”,“e”,“h”]<br>示例 2：</p><p>输入：[“H”,“a”,“n”,“n”,“a”,“h”]<br>输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p><p>来源：力扣（LeetCode）</p></blockquote><blockquote><p>链接：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></p></blockquote><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li><p>就地操作，而且要是O(1)的空间，可以使用迭代方法，首尾指针解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span> ; i++)&#123;</span><br><span class="line">            tmp = s[i];</span><br><span class="line">            s[i] =  s[len - i - <span class="number">1</span>]; <span class="comment">//这是末尾的值</span></span><br><span class="line">            s[len-i-<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>也可以用递归来做，但是使用了辅助栈，不满足O(1)的空间要求</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        help(s, <span class="number">0</span>, s.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">        help(s, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p><a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/Str/leetcode344_ReverseStr.java" target="_blank" rel="noopener">https://github.com/Castile/algorithm/blob/master/leetcode/src/Str/leetcode344_ReverseStr.java</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="递归" scheme="https://Castile.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="字符串" scheme="https://Castile.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-24-两两交换链表中的节点</title>
    <link href="https://castile.github.io/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://castile.github.io/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</id>
    <published>2020-02-03T08:18:28.000Z</published>
    <updated>2020-02-03T08:51:25.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h1><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例：</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></p></blockquote><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1><ol><li><p>递归：</p><p>​我们可以定义函数 swap(head) 以实现解决方案，其中输入的参数 head 指向链表的头节点。* 而该函数应当返回将链表中每两个相邻节点交换后得到的新列表的头节点 head 。</p><p>​按照我们上面列出的步骤，我们可以按下面的流程来实现函数：</p><p>​（1）首先，我们交换列表中的前两个节点，也就是 head 和 head.next；</p><p>​（2）然后我们以 swap(head.next.next) 的形式调用函数自身，以交换头两个节点之后列表的其余部分。</p><p>​（3）最后，我们将步骤（2）中的子列表的返回头与步骤（1）中交换的两个节点相连，以形成新的链表。</p></li><li><p>迭代</p><p>新增一个头节点 dummy node， dummy.next = head； 更好操作链表。流程图如下：</p><a href="/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1580719129953.png" data-fancybox="group" data-caption="1580719790068" class="fancybox"><img alt="1580719790068" style="zoom:80%;" data-src="/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1580719129953.png" class="lazyload" title="1580719790068"></a></li></ol><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>源码： <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode24_SwapNodesInPairs.java" target="_blank" rel="noopener">https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode24_SwapNodesInPairs.java</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-03 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode24_SwapNodesInPairs</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)     <span class="keyword">return</span> head;</span><br><span class="line">        ListNode n = head.next.next;  <span class="comment">// 下一次要传递的节点</span></span><br><span class="line">        <span class="comment">//交换这两个节点</span></span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        p.next = head;</span><br><span class="line">        head.next = swapPairs(n); <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 返回交换之后的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs_it</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode first = head;</span><br><span class="line">            ListNode second = head.next;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            pre.next = second;</span><br><span class="line">            <span class="comment">// 初始化头</span></span><br><span class="line">            head = first.next;</span><br><span class="line">            pre = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://Castile.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="链表" scheme="https://Castile.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-200-岛屿数量</title>
    <link href="https://castile.github.io/2020/02/02/leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>https://castile.github.io/2020/02/02/leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-02-02T09:50:20.000Z</published>
    <updated>2020-02-02T11:24:58.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p>示例 1:</p><p>输入:<br>11110<br>11010<br>11000<br>00000</p><p>输出: 1<br>示例 2:</p><p>输入:<br>11000<br>11000<br>00100<br>00011</p><p>输出: 3<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li>dfs： 深度优先搜索，很明显，这是一个连通问题，求出的连通分量的个数就是岛屿的数量</li><li>并查集： 这个是并查集的一个应用，求连通分量的个数。</li><li>bfs： 使用队列解决</li></ol><p>这里有一个大佬的题解，非常详细： <a href="https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/</a></p><p>官方题解也可。主要是理解算法思想</p><p>直接看代码吧</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>并查集：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">        <span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        makeSet(grid, parents, rank);</span><br><span class="line">        <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">        <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>( grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                   grid[i][j] = <span class="string">'0'</span>;  <span class="comment">//  已经联合的点不需要连接了。</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                       <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                       <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                       <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                           unoin(parents, rank, x *n +y,  i *n + j);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建并查集的结构：注意这里的技巧</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> []parents, <span class="keyword">int</span> []rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    parents[i * grid[<span class="number">0</span>].length + j] = i * grid[<span class="number">0</span>].length + j;</span><br><span class="line">                    rank[i * grid[<span class="number">0</span>].length + j] = <span class="number">1</span>;</span><br><span class="line">                    count++;  <span class="comment">// 连通分量 </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parents[i * grid[<span class="number">0</span>].length + j] = -<span class="number">1</span>;</span><br><span class="line">                    rank[i * grid[<span class="number">0</span>].length + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;    </span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parents[a];</span><br><span class="line">        <span class="keyword">while</span>(root != parents[root])&#123;</span><br><span class="line">           root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unoin</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> []rank, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ra  = find(parents, a);</span><br><span class="line">        <span class="keyword">int</span> rb  = find(parents, b);</span><br><span class="line">        <span class="keyword">if</span>(ra != rb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank[ra] &gt; rank[rb])&#123;</span><br><span class="line">                parents[rb] =  ra;</span><br><span class="line">                rank[ra] += rank[rb];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 parents[rb] =  ra;</span><br><span class="line">                rank[ra] += rank[rb];</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>dfs：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    cnt++; <span class="comment">// 岛屿的个数加一</span></span><br><span class="line">                    infect(grid, i, j, grid.length, grid[<span class="number">0</span>].length); <span class="comment">// 感染函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 感染函数： 将i， j位置的上下左右位置进行检查，是否为同一个岛屿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m： 岛屿矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i： 下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j：  下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R: 行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C： 列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= R || j &lt; <span class="number">0</span> || j &gt;= C || m[i][j] != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        m[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        <span class="comment">// 依次感染上下左右位置</span></span><br><span class="line">        infect(m, i+<span class="number">1</span>, j, R, C);</span><br><span class="line">        infect(m, i-<span class="number">1</span>, j, R, C);</span><br><span class="line">        infect(m, i, j-<span class="number">1</span>, R, C);</span><br><span class="line">        infect(m, i, j+<span class="number">1</span>, R, C);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>BFS： 使用队列</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> ||  grid.length == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    q.offer(i * n + j); <span class="comment">//  入队</span></span><br><span class="line">                    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = q.poll(); <span class="comment">// 出队</span></span><br><span class="line">                    <span class="keyword">int</span> cx = cur / n;</span><br><span class="line">                    <span class="keyword">int</span> cy = cur % n;</span><br><span class="line">                    grid[cx][cy] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span>[] dd: d)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = cx + dd[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = cy + dd[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.offer(x * n + y);</span><br><span class="line">                            grid[x][y] = <span class="string">'0'</span>;   <span class="comment">// 要标志已访问，不然会严重超时</span></span><br><span class="line">                        &#125;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="搜索" scheme="https://Castile.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-695-岛屿的最大面积</title>
    <link href="https://castile.github.io/2020/02/02/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <id>https://castile.github.io/2020/02/02/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-02-02T09:44:04.000Z</published>
    <updated>2020-02-02T09:49:39.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><p>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-area-of-island</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>dfs： 岛屿问题，看到连通区域，想到dfs来做。 用DFS搜索每个value为1的位置，递归检查相邻的位置，如果访问过，则将value设为0（避免重复访问）</p><p>直接看代码注释</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-02 17:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_695_MaxAreaIsland</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++)&#123;</span><br><span class="line">                result = Math.max(result, dfs(grid, i, j)); <span class="comment">//求最大的面积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    int[][] d = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>; <span class="comment">// 面积加1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123; <span class="comment">//  注意使用不同的变量，如果使用x、y会报错</span></span><br><span class="line">            <span class="keyword">int</span> i = x + d[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> j = y + d[k][<span class="number">1</span>];</span><br><span class="line">            c += dfs(grid, i, j);  <span class="comment">// 搜索上下左右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int[] dd: d)&#123;</span></span><br><span class="line">        <span class="comment">//     c += dfs(grid, x + dd[0], y + dd[1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="搜索" scheme="https://Castile.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-268-缺失的数字</title>
    <link href="https://castile.github.io/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://castile.github.io/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-02T02:54:27.000Z</published>
    <updated>2020-02-02T04:07:17.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>[toc]</p><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。</p><p>示例 1:</p><p>输入: [3,0,1]<br>输出: 2<br>示例 2:</p><p>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8<br>链接：<a href="https://leetcode-cn.com/problems/missing-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/missing-number</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>题目说从0~n的数字，所以直接累加数组得到和为sum， 加入数组没有缺失数据，那么完整数组的元素个数为原数组大小加1，利用等差数列的性质，得到从0~n的和len，然后len - sum 就是缺失的那个数字了。</p><p>时间复杂度：O(n)。求出数组中所有数的和的时间复杂度为 O(n)，等差数列公式的时间复杂度为 O(1)，因此总的时间复杂度为 O(n)。<br>空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。</p></li><li><p>位操作： 异或</p><table><thead><tr><th>a</th><th>b</th><th style="text-align:center">异或结果</th></tr></thead><tbody><tr><td>0</td><td>0</td><td style="text-align:center">0</td></tr><tr><td>0</td><td>1</td><td style="text-align:center">1</td></tr><tr><td>1</td><td>0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td>1</td><td style="text-align:center">0</td></tr></tbody></table><p>其他数字 与 0 异或都得到它自己。</p><p>此外异或运算满足交换律.  如：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><p>下标与数组值异或操作：  4 ^ 0 ^ 3 ^ 1 ^  4 ^ 2 ^ 0 ^ 3 ^ 1 ( 前面的4是为了添加最后一位数字，为原数组的长度) ----&gt; 可得到缺失的值为2。</p><p>时间复杂度：O(n)。这里假设异或运算的时间复杂度是常数的，总共会进行O(n) 次异或运算，因此总的时间复杂度为 O(n)。<br>空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。</p></li><li><p>哈希表</p><p>将数组中的元素放入HashSet哈希表中， 插入哈希表的时间复杂度为O(1)， N个数时间复杂度为O(n)， 然后从0到数组放长度区间内遍历， 判断哈希表中是否存在此数字，若不存在， 则此数字就是缺失的数字。遍历时间复杂度为O(n)，  故总体时间复杂度为O(n)。空间复杂度为O(n)。</p></li><li><p>还可以先排序，再找出缺失的数字，但是排序的时间复杂度不是线性时间， 为O(logN)</p></li></ol><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>方法一：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123; <span class="comment">//数组的和</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缺失一个数字： 本来的和应该是：  </span></span><br><span class="line">        <span class="keyword">int</span> len = (nums.length + <span class="number">1</span>) * nums.length / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> len - sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614821325.png" data-fancybox="group" data-caption="1580614821325" class="fancybox"><img alt="1580614821325" style="zoom:80%;" data-src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614821325.png" class="lazyload" title="1580614821325"></a><p>位操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; nums.length; i++)&#123;</span><br><span class="line">            m ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614957343.png" data-fancybox="group" data-caption="1580614957343" class="fancybox"><img alt="1580614957343" style="zoom:80%;" data-src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614957343.png" class="lazyload" title="1580614957343"></a><p>哈希表：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.contains(i))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580615699820.png" data-fancybox="group" data-caption="1580615699820" class="fancybox"><img alt="1580615699820" style="zoom:80%;" data-src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580615699820.png" class="lazyload" title="1580615699820"></a><p>排序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      <span class="comment">// 判断末尾</span></span><br><span class="line">      <span class="keyword">if</span>(nums[nums.length - <span class="number">1</span>] !=  nums.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> nums.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断0 是否在首位</span></span><br><span class="line">      <span class="keyword">if</span>(nums[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i != nums[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580616038690.png" data-fancybox="group" data-caption="1580616038690" class="fancybox"><img alt="1580616038690" style="zoom:80%;" data-src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580616038690.png" class="lazyload" title="1580616038690"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="位操作" scheme="https://Castile.github.io/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java-集合框架</title>
    <link href="https://castile.github.io/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://castile.github.io/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-02-01T02:49:50.000Z</published>
    <updated>2020-02-11T03:54:33.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述"></a> 一、 概述</h1><h2 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h2><p>​集合是存储对象的容器，集合中可以存储任意类型的对象，而且长度可变。在程序中有可能无法预先知道需要多少个对象，那么用数组来装对象的话，长度不好定义，而集合解决了这样的问题。</p><p>​ 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580527655939.png" data-fancybox="group" data-caption="1580527655939" class="fancybox"><img alt="1580527655939" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580527655939.png" class="lazyload" title="1580527655939"></a><p><code>注： 带对号的是线程安全类。</code></p><h3 id="集合和数组的区别"><a class="markdownIt-Anchor" href="#集合和数组的区别"></a> 集合和数组的区别</h3><p>数组和集合类都是容器</p><ul><li><p>数组长度是<strong>固定的</strong>，集合长度是<strong>可变的</strong>。数组中可以存储基本数据类型，<strong>集合只能存储对象</strong></p></li><li><p>数组中存储数据类型是单一的，集合中可以存储任意类型的对象。</p></li><li><p>集合类的特点：<code>用于存储对象，长度是可变的，可以存储不同类型的对象。</code></p></li></ul><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection.png" data-fancybox="group" data-caption="collection" class="fancybox"><img alt="collection" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection.png" class="lazyload" title="collection"></a><ul><li>从上图可以看到，Set、List、Queue都是继承Collection接口。（Map是接口，下面会详细描述）</li><li>Set下面有HashSet、LinkedHashSet以及一个SortedSet接口，TreeSet继承SortedSet接口，说明TreeSet里面的元素一定是有序的。</li><li>List下面有ArrayList、Vector、 LinkedList</li><li>Queue下面有LinkedList和PriorityQueue类(堆结构：优先级队列)，说明LinkedLIst可以当做队列来使用。</li></ul><h3 id="1-set唯一性"><a class="markdownIt-Anchor" href="#1-set唯一性"></a> 1. Set：唯一性</h3><h4 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h4><p>基于<strong>红黑树</strong>实现，支持<strong>有序性</strong>操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。红黑树的算法规则是<strong>左小右大</strong>。</p><ol><li><p>红黑树是一种特定类型的二叉树， 是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><p>​性质1：每个节点要么是黑色，要么是红色。</p><p>​性质2：根节点是黑色。</p><p>​性质3：每个叶子节点（NIL）是黑色。</p><p>​性质4：每个红色结点的两个子结点一定都是黑色。</p><p>​<strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></p><p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2392382-4996bbfb4017a3b2.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2392382-4996bbfb4017a3b2.png" class="lazyload" title="img"></a></p><p>红黑树以后会补上，详解见： <a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a></p></li><li><p>TreeSet可以自然排序，那么TreeSet必定具有排序规则的</p><p>​① 元素自身具有比较性，需要实现Comparable接口，重写compareTo方法。这种方式叫做元素的自然排序</p><p>​② 容器具备比较性，当元素不具备比较性，或者自身具备的比较性不是所需要的，那么此时也可以让容器自身具备。需要定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。（<code>注： 当Comparable比较方式和Comparator比较方式同时存在，以Comparator为主</code>）</p><p>​③ 基本数据类型具备自身比较性，比如String， int等，String内部已经继承了Comparable接口，所以具备比较性，我们自己定义的元素，想要存入TreeSet中，就必须自己实现该接口，也就是说要让对象具备就比较性，如果存入相同的元素则只会存入一个到TreeSet中。</p><p>​④ TreeSet中如何保证元素的唯一性： 通过compareTo或者compare方法来保证元素的唯一性。</p><p>Person类中有name和age属性，下面是重写的compareTo方法以及hashCode和equals方法。这是使元素自身具备比较性：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nama.hashCode() + age*<span class="number">33</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!(obj  <span class="keyword">instanceof</span>  Person))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Person p = (Person)obj;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.nama.equals(p.nama) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       Person p = (Person)o;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; p.age)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt;  p.age)&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.nama.compareTo(p.nama);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>下面是是使容器自身具备比较性，要自定义比较器：定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Person p1 = (Person) o1;</span><br><span class="line">        Person p2 = (Person) o2;</span><br><span class="line">        <span class="comment">// 首先比较年龄，年龄不一样就是不同元素，因为存在同名的人</span></span><br><span class="line">        <span class="keyword">if</span>(p1.getAge() &gt; p2.getAge())&#123; <span class="comment">// 按照年龄升序排列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( p1.getAge() &lt; p2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果年龄相同则比较姓名</span></span><br><span class="line">        <span class="keyword">return</span> p1.getNama().compareTo(p2.getNama());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> MyComparator()); <span class="comment">// 传入比较器</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="number">24</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">"tom"</span> , <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p: set)&#123;</span><br><span class="line">            out.println(p.getNama()+<span class="string">"   "</span>+p.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">输出： </span><br><span class="line">李四   <span class="number">5</span></span><br><span class="line">张三   <span class="number">12</span></span><br><span class="line">李四   <span class="number">12</span></span><br><span class="line">tom   <span class="number">24</span></span><br><span class="line"></span><br><span class="line">可以看到重名的tom是相同的元素，智慧添加一个到TreeSet中，并且输出的顺序是按照年龄大小排列的</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h4><p>基于<strong>哈希表</strong>实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。（无序）</p><ol><li><p>HashSet是按照哈希值来存数据的，所以取数据也是按照哈希值取得的。</p></li><li><p>Set具有元素的唯一性，所以HashSet也具有此特性。</p></li><li><p>HashSet如何检查重复呢？</p><blockquote><p>​HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放对个元素。元素的哈希值是通过元素的hashCode方法来获取的， HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法；如果hashCode不一样就不会再调用equals方法了。如果equals方法返回true，那么HashSet认为新加入的对象重复了加入失败。如果equals方法为false那么HashSet认为新加入的对象没有重复，新元素可以加入。</p></blockquote></li></ol><h4 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h4><p>具有 HashSet 的查找效率，并且内部使用<strong>双向链表</strong>维护元素的插入顺序。（有序）</p><ol><li>由链表保证元素有序</li><li>由哈希表保证元素唯一</li></ol><h3 id="2-list"><a class="markdownIt-Anchor" href="#2-list"></a> 2. List</h3><p>List特有的方法</p><blockquote><p>1： 增加</p><p>​void add(int index, E elem) 指定位置添加元素</p><p>​boolean addAll(int index, COllection c)   指定位置添加集合</p><p>2： 删除</p><p>​E remove(int index)删除指定位置元素</p><p>3： 查找</p><p>​E get(int index)注意 IndexOutOfBoundsException</p><p>​int indexOf(Object o) 找不到返回 -1</p><p>​lastIndexOf(Object o)</p><p>4： 修改</p><p>​E set(int index, E elem)   返回的是需要替换的集合中的元素</p><p>5： 求子集合</p><p>​List<e> subList(int fromIndex, int toIndex)  //   包含toIndex</e></p></blockquote><h4 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h4><p>基于动态数组实现，支持随机访问。 底层采用数组实现， 默认为10. 查询快，增删慢。在实际开发过程中，ArrayList 是使用频率最高的一个集合。</p><h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h4><p>和 ArrayList 类似，但它是线程安全的。描述的是一个线程安全的ArrayList</p><p>ArrayList： 单线程效率高</p><p>Vector：  多线程安全， 所以效率低</p><p>特有的方法</p><blockquote><p>​void addElement(E obj) 在集合末尾添加元素</p><p>​E elementAt(int index)返回指定角标的元素</p><p>​Enumeration elements()  返回集合中的所有元素， 封装到Enumeration对象中</p><p>​Enumeration 接口：</p><p>​boolean hashMoreElements() 测试此枚举的对象是否包含更多的元素</p><p>​E  nextElement()返回下一个元素</p></blockquote><h4 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h4><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，<strong>LinkedList 还可以用作栈、队列和双向队列。</strong></p><p>​1. 特有方法：</p><blockquote><p>​addFirst(E  e)</p><p>​addLast(E  e)</p><p>​getFirst( )</p><p>​getLast( )</p><p>​removeFirst()</p><p>​removeLast()</p></blockquote><ol start="2"><li><p>数据结构</p><blockquote><p>1： 栈（1.6）：push()   pop()</p><p>2:   队列 ： offer()    poll()</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line">   LinkedList list  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">   list.push(<span class="number">2</span>);</span><br><span class="line">   list.push(<span class="number">4</span>);</span><br><span class="line">   list.push(<span class="number">5</span>);</span><br><span class="line">   list.push(<span class="number">6</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Iterator it = list.iterator();</span><br><span class="line">   <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">       out.println(it.next());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>输出：</p><p>6<br>5<br>4<br>2</p><p>模拟队列：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LinkedList q  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  q.offer(<span class="number">2</span>);</span><br><span class="line">  q.offer(<span class="number">3</span>);</span><br><span class="line">  q.offer(<span class="number">5</span>);</span><br><span class="line">   </span><br><span class="line">  q.poll();</span><br><span class="line">   </span><br><span class="line">  Iterator it1 = q.iterator();</span><br><span class="line">  <span class="keyword">while</span> (it1.hasNext())&#123;</span><br><span class="line">      out.println(it1.next());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li><p>返回逆序的迭代器对</p><blockquote><p>​descendingItrerator()   返回逆序的迭代器对象</p></blockquote></li></ol></li></ol><h3 id="3-queue"><a class="markdownIt-Anchor" href="#3-queue"></a> 3. Queue</h3><h4 id="linkedlist-2"><a class="markdownIt-Anchor" href="#linkedlist-2"></a> LinkedList</h4><p>​可以用它来实现双向队列。</p><h4 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h4><p>​基于堆结构实现，可以用它来实现优先队列。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><blockquote><p>看到Array： 想到角标</p><p>看到Link： 想到first、last</p><p>看到Hash： 想到hashCode、equals</p><p>看到Tree： 想到两个接口： Comparable、 Comparator</p></blockquote><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2><p>Map与Collection在框架中属并两列存在。interface Map&lt;K, V&gt;</p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580552945802.png" data-fancybox="group" data-caption="map" class="fancybox"><img alt="map" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580552945802.png" class="lazyload" title="map"></a><p>Map一次存储一对元素，Collection一次存一个。Map的键不能重复，保证唯一。</p><h3 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h3><p>​基于红黑树实现。可以对键进行排序。排序方法和TreeSet中类似，对于不具备比较性的对象需要自定义比较器传入容器中。</p><h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h3><p>​基于哈希表实现， 无序，线程不同步，要保证键的唯一性，需要重写hashCode方法和equals方法。</p><h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h3><ul><li>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>Hashtable不允许null值，HashMap允许null值（key和value都允许 )</li><li>效率比HashMap低</li></ul><h3 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h3><p>​继承了HashMap。使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p><h2 id="遍历"><a class="markdownIt-Anchor" href="#遍历"></a> 遍历</h2><h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3><blockquote><p>迭代器： 为了方便处理集合中的元素，出现了迭代器对象。这个对象比较特殊，不能通过new来创建，它是以<strong>内部类</strong>的形式存在于每个集合的内部。</p></blockquote><p>​每个容器都能取出元素的功能，定义一样，只不过不同的容器使用的数据结构不同而导致取出元素的具体实现不一样，将共性抽取出来形成Iterator接口。每一个容易在其内部进行了内部类的实现。也就是将取出元素的方式的细节进行封装。</p><h3 id="iterable"><a class="markdownIt-Anchor" href="#iterable"></a> Iterable</h3><p>JDK1.5后的新接口。Collection继承了此接口，实现了Iterable的类就是可以进行迭代的，并且支持增强for循环。</p><h3 id="iterator"><a class="markdownIt-Anchor" href="#iterator"></a> Iterator</h3><p>Iterable 接口只有一个返回迭代器的方法Iterator().  Iterator是迭代器对象。</p><blockquote><p>Iteartor<t>   Iterator()   返回该集合的迭代器对象</t></p></blockquote><p>while循环进行迭代器遍历：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      LinkedList list  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      list.push(<span class="number">2</span>);</span><br><span class="line">      list.push(<span class="number">4</span>);</span><br><span class="line">      list.push(<span class="number">5</span>);</span><br><span class="line">      list.push(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">      Iterator it = list.iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          out.println(it.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div><p>for循环：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator it = list.iterator(); it.hasNext();)&#123;</span><br><span class="line">            out.println(it.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><p>推荐使用for循环，因为可以进行内存上的优化。</p><blockquote><ol><li><p>如果迭代器的指针已经指向了集合的末尾， 那么如果再调用next() 会返NoSuchElementException                                  异常。</p></li><li><p>如果调用move方法之前没用调用next是不合法的。会抛出IllegaStateException</p></li></ol></blockquote><h3 id="迭代器原理"><a class="markdownIt-Anchor" href="#迭代器原理"></a> 迭代器原理</h3><p>ArrayList： 看源码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>看看Itr()  方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return 下一个元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前的下标大小不等于容器个元素个数 就 说明还有下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回下一个元素</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)  <span class="comment">//  没有下一个元素了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>; <span class="comment">// 当前的cursor要指向下一个</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];  <span class="comment">// 返回元素 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><p>来看看上面代码的<code>checkForComodification();</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div><p>​在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作， 因为这样会产生安全隐患，java会抛出异常并发修改异常<code>ConcurrentModificationException</code>， 普通迭代器只支持在迭代过程中的删除操作。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(<span class="string">"aaa"</span>);</span><br><span class="line">       list.add(<span class="string">"bbb"</span>);</span><br><span class="line">       list.add(<span class="string">"ccc"</span>);</span><br><span class="line">       list.add(<span class="string">"ddd"</span>);</span><br><span class="line">       list.add(<span class="string">"eee"</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       Iterator it =  list.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">           it.next();</span><br><span class="line">           it.remove();</span><br><span class="line">           list.add(<span class="string">"aaaaa"</span>); <span class="comment">// 出现了迭代器以外的对元素的操作</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>​报错：</p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580558907260.png" data-fancybox="group" data-caption="1580558907260" class="fancybox"><img alt="1580558907260" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580558907260.png" class="lazyload" title="1580558907260"></a><h3 id="list-特有的迭代器listiterator"><a class="markdownIt-Anchor" href="#list-特有的迭代器listiterator"></a> List 特有的迭代器ListIterator</h3><p>如果想在迭代元素的过程中操作集合的元素，那么可以使用LIst特有的迭代器对象ListIterator，该迭代器可支持在迭代的过程中添加元素和修改元素。</p><p>implements ListIterator<e> 接口</e></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">           <span class="keyword">super</span>();</span><br><span class="line">           cursor = index;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有前一个元素</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 返回下一个元素的下标</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 返回前一个元素的下标</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 返回前一个元素： 可以逆序访问</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line">           <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           cursor = i;</span><br><span class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 用指定元素替换next或者 previous返回的最后一个元素</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 将指定的元素加入列表，钙元素直接插入到next元素的后面</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> i = cursor;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">               cursor = i + <span class="number">1</span>;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>测试 set方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(<span class="string">"aaa"</span>);</span><br><span class="line">       list.add(<span class="string">"bbb"</span>);</span><br><span class="line">       list.add(<span class="string">"ccc"</span>);</span><br><span class="line">       list.add(<span class="string">"ddd"</span>);</span><br><span class="line">       list.add(<span class="string">"eee"</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       ListIterator it = list.listIterator();</span><br><span class="line">      System.out.println(it.next());</span><br><span class="line">      it.set(<span class="string">"zhu"</span>);</span><br><span class="line">      System.out.println(list);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>输出：</p><p>[aaa, bbb, ccc, ddd, eee]<br>aaa<br>[zhu, bbb, ccc, ddd, eee]</p></blockquote><p>测试 add方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line">        list.add(<span class="string">"ddd"</span>);</span><br><span class="line">        list.add(<span class="string">"eee"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">       System.out.println(it.next());</span><br><span class="line">       it.add(<span class="string">"zhu"</span>);  <span class="comment">// 在aaa之后添加zhu</span></span><br><span class="line">       System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>输出：</p><p>[aaa, bbb, ccc, ddd, eee]<br>aaa<br>[aaa, zhu, bbb, ccc, ddd, eee]</p></blockquote><h3 id="遍历map"><a class="markdownIt-Anchor" href="#遍历map"></a> 遍历Map</h3><p>有三种方式：</p><ol><li>keySet() 获取Map中的所有键，转换成Set集合，然后遍历该Set，通过get方法获取键对应的值</li><li>values() 方法来获取所有值 ：Collection<v> values()  不能获取到key对象</v></li><li><strong>Map.Entry对象：重点！！！！推荐使用</strong>： Interface Map.Entry&lt;K,V&gt;</li></ol><h4 id="mapentry"><a class="markdownIt-Anchor" href="#mapentry"></a> Map.Entry</h4><p><code>public static interface Map.Entry&lt;K,V&gt;</code></p><p>将map集合中的键值对关系打包成一个Map.Entry对象，将该对象存入Set结合中，使用getKey() 和 getValue()来获取键和值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"aaa"</span>, <span class="number">123</span>);</span><br><span class="line">       map.put(<span class="string">"bbb"</span>, <span class="number">345</span>);</span><br><span class="line">       map.put(<span class="string">"ccc"</span>, <span class="number">121</span>);</span><br><span class="line">       map.put(<span class="string">"ddd"</span>, <span class="number">675</span>);</span><br><span class="line"></span><br><span class="line">       Set&lt;Map.Entry&lt;String, Integer&gt;&gt; s = map.entrySet();</span><br><span class="line">       Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = s.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           Map.Entry&lt;String, Integer&gt; en = iterator.next();</span><br><span class="line">           System.out.println(<span class="string">"键： "</span>+ en.getKey()+<span class="string">" 值："</span>+ en.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>键： aaa 值：123<br>键： ccc 值：121<br>键： bbb 值：345<br>键： ddd 值：675</p></blockquote><hr><h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h2><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p><hr><h3 id="一-arraylist"><a class="markdownIt-Anchor" href="#一-arraylist"></a> 一、 ArrayList</h3><h4 id="1-概览"><a class="markdownIt-Anchor" href="#1-概览"></a> 1. 概览</h4><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default initial capacity.  数组的默认大小为10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581256240358.png" data-fancybox="group" data-caption="1581256240358" class="fancybox"><img alt="1581256240358" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581256240358.png" class="lazyload" title="1581256240358"></a><h4 id="2-扩容"><a class="markdownIt-Anchor" href="#2-扩容"></a> 2. 扩容</h4><p>​添加元素时使用  <code>ensureCapacityInternal()</code>  方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，新容量的大小为   <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>  ，也就是旧容量的 1.5 倍。</p><p>​ 扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-删除元素"><a class="markdownIt-Anchor" href="#3-删除元素"></a> 3. 删除元素</h4><pre><code>需要调用      `System.arraycopy()`     将    `index+1 `      后面的元素都复制到 `index` 位置上，该操作的时间复杂度为 `O(N)`，可以看到 ArrayList 删除元素的代价是非常高的。 </code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h4 id="4-序列化"><a class="markdownIt-Anchor" href="#4-序列化"></a> 4. 序列化</h4><p>​ArrayList 基于数组实现，并且具有<strong>动态扩容特性</strong>，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>​保存元素的数组 elementData 使用 <code>transient</code> 修饰，<strong>该关键字声明数组默认不会被序列化</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></div><p>​ArrayList 实现了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制只序列化数组中有元素填充那部分内容。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment">     * deserialize it).  反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="class">.<span class="keyword">class</span>, <span class="title">capacity</span>)</span>;</span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment">    * is, serialize it).  序列化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment">    *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment">    只序列化数组中有元素填充那部分内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">       <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">       <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">       s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">       s.writeInt(size);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>​ 序列化时需要使用 <code>ObjectOutputStream</code> 的 <code>writeObject()</code> 将对象转换为字节流并输出。而 <code>writeObject()</code> 方法在传入的对象存在 <code>writeObject()</code> 的时候会去反射调用该对象的 <code>writeObject()</code> 来实现序列化。反序列化使用的是 <code>ObjectInputStream</code> 的 <code>readObject()</code> 方法，原理类似。</p><h4 id="5-fail-fast"><a class="markdownIt-Anchor" href="#5-fail-fast"></a> 5. Fail-Fast</h4><p>​<strong><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数</strong>。</p><blockquote><p>​结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p></blockquote><p>​在进行序列化或者迭代等操作时，需要比较操作前后 <code>modCount</code> 是否改变，如果改变了需要抛出 <code>ConcurrentModificationException</code>。代码参考上节序列化中的 <code>writeObject()</code> 方法。</p><p>​ <code>fail-fast</code> 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生<code>fail-fast</code>事件。例如：当某一个线程A通过<code>iterator</code>去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出<code>ConcurrentModificationException</code>异常，产生<code>fail-fast</code>事件。</p><blockquote><p>​ <code>ConcurrentModificationException</code> 异常 ：  当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。</p></blockquote><p>​诚然，迭代器的<strong>快速失败</strong>行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出<code>ConcurrentModificationException</code>异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 bug。</p><p>​ 线程环境下产生该异常的原因是在迭代器遍历集合时，使用了集合本身的<code>remove</code>方法而不是迭代器的；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​在ArrayList进行<code>add</code>，<code>remove</code>，<code>clear</code>等涉及到修改集合中的元素个数的操作时，<code>modCount</code>就会发生改变<code>(modCount ++)</code>,所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使<code>modCount</code>发生变化，这样在<code>checkForComodification</code>方法中就会抛出<code>ConcurrentModificationException</code>异常。</p><p><code>fail-fast</code>会在以下两种情况下抛出<code>ConcurrentModificationException</code> ：</p><blockquote><p>（1）单线程环境</p><p>集合被创建后，在遍历它的过程中修改了结构。</p><p>注意 <code>remove()</code>方法会让<code>expectModcount</code>和<code>modcount</code> 相等，所以是不会抛出这个异常。</p><p>（2）多线程环境</p><p>当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</p></blockquote><p><strong>问题</strong>： fail-fast机制是如何检测的？</p><p>​迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “<code>modCount</code>” ，当集合结构改变（添加删除或者修改），标记&quot;<code>modCount</code>“会被修改，而迭代器每次的<code>hasNext()</code>和<code>next()</code>方法都会检查该”<code>modCount</code>&quot;是否被改变，当检测到被修改时，抛出<code>ConcurrentModificationException</code></p><h5 id="单线程情况"><a class="markdownIt-Anchor" href="#单线程情况"></a> 单线程情况</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">           list.add(i + <span class="string">""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                list.remove(<span class="number">3</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">           i ++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述代码是ArrayList单线程环境下的fail-fast ， 该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。</p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581309298345.png" data-fancybox="group" data-caption="1581309298345" class="fancybox"><img alt="1581309298345" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581309298345.png" class="lazyload" title="1581309298345"></a><p>如果将以上代码修改成在next之后进行迭代器的remove操作，就不会报错。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">            list.add(i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">//  在next之后进行迭代器的remove操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>输出：</p><blockquote><p>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>[0, 1, 2, 4, 5, 6, 7, 8, 9]</p></blockquote><p>​所以，在对集合进行迭代过程中，<strong>不允许出现迭代器以外的对元素的操作</strong>， 因为这样会产生安全隐患，java会抛出异常并发修改异常<code>ConcurrentModificationException</code>， 普通迭代器只支持在迭代过程中的删除操作。</p><p>类似的，hashMap中发生的原理也是一样的。</p><p>HashMap发生fail-fast ：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++ ) &#123;</span><br><span class="line">           map.put(i+<span class="string">""</span>, i+<span class="string">""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                map.remove(<span class="number">3</span>+<span class="string">""</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">           System.out.println(<span class="string">"key= "</span> + entry.getKey() + <span class="string">" and value= "</span> + entry.getValue());</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了<code>ConcurrentModificationException</code>异常：</p><p>​<a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310117229.png" data-fancybox="group" data-caption="1581310117229" class="fancybox"><img alt="1581310117229" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310117229.png" class="lazyload" title="1581310117229"></a></p><p>类似，next之后调用迭代器的remove就可以成功删除。</p><h5 id="多线程情况"><a class="markdownIt-Anchor" href="#多线程情况"></a> 多线程情况</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-10 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFastTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String s = iterator.next();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + s);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread2:"</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    list.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            list.add(i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread1.setName(<span class="string">"thread1"</span>);</span><br><span class="line">        thread2.setName(<span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了<code>java.util.ConcurrentModificationException</code></p><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310760678.png" data-fancybox="group" data-caption="1581310760678" class="fancybox"><img alt="1581310760678" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310760678.png" class="lazyload" title="1581310760678"></a><h5 id="避免fail-fast"><a class="markdownIt-Anchor" href="#避免fail-fast"></a> <strong>避免fail-fast</strong></h5><p>方法一:</p><pre><code>在单线程的遍历过程中，如果要进行`remove`操作，可以调用迭代器的`remove`方法而不是集合类的`remove`方法。看看ArrayList中迭代器的remove方法的源码:</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;  <span class="comment">/// 不会修改modCount，而是令其余expectedModCount相等</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​ 可以看到，该remove方法并不会修改<code>modCount</code>的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生<code>fail-fast</code>现象。该方法有局限性，就是上面说的，只能代用next方法之后再调用迭代器的remove方法。</p><p>方法二：安全失败</p><p>​使用java并发包<code>(java.util.concurrent)</code>中的类来代替ArrayList 和hashMap。<br>​比如使用 <code>CopyOnWriterArrayList</code>代替<code>ArrayList</code>，<code>CopyOnWriterArrayList</code>在是使用上跟<code>ArrayList</code>几乎一样，<code>CopyOnWriter</code>是写时复制的容器(COW)，在读写时是线程安全的。该容器在对<code>add</code>和<code>remove</code>等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于<code>CopyOnWriterArrayLis</code>t在迭代过程并不会发生<code>fail-fast</code>现象。<strong>但 <code>CopyOnWrite</code>容器只能保证数据的最终一致性，不能保证数据的实时一致性。</strong><br>​对于<code>HashMap</code>，可以使用<code>ConcurrentHashMap</code>，<code>ConcurrentHashMap</code>采用了<strong>锁机制</strong>，<strong>是线程安全的</strong>。在迭代方面，<code>ConcurrentHashMap</code>使用了一种不同的迭代方式。在这种迭代方式中，当<code>iterator</code>被创建后集合再发生改变就不再是抛出<code>ConcurrentModificationException</code>，取而代之的是：在改变时<code>new</code>新的数据从而不影响原有的数据 ，<code>iterator</code>完成后再将头指针替换为新的数据 ，这样<code>iterator</code>线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生<code>fail-fast</code>，但不保证获取的是最新的数据。</p><h4 id="6-安全失败failsafe"><a class="markdownIt-Anchor" href="#6-安全失败failsafe"></a> 6. 安全失败（fail—safe）</h4><pre><code>快速失败（Fail-Fast）的场景： `java.util`包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 </code></pre><p>​采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。比如上面说的COW</p><pre><code> 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</code></pre><p>​     场景：<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><blockquote><p>并发修改 ： 当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。这就是并发修改 。</p></blockquote><p>fail-safe机制有两个问题</p><p>（1）需要复制集合，产生大量的无效对象，开销大。</p><p>（2）无法保证读取的数据是目前原始数据结构中的数据。</p><h4 id="7-fail-fast和-fail-safe-的区别"><a class="markdownIt-Anchor" href="#7-fail-fast和-fail-safe-的区别"></a> 7.  fail-fast和 fail-safe 的区别</h4><table><thead><tr><th></th><th style="text-align:center">Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td style="text-align:center">Yes</td><td>No</td></tr><tr><td>Clone object</td><td style="text-align:center">No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td style="text-align:center">No</td><td>Yes</td></tr><tr><td>Examples</td><td style="text-align:center">HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList, ConcurrentHashMap</td></tr></tbody></table><hr><h3 id="二-vector"><a class="markdownIt-Anchor" href="#二-vector"></a> 二、 Vector</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></div><p>也继承了RandomAccess接口， 可以随机访问。</p><h4 id="1-同步"><a class="markdownIt-Anchor" href="#1-同步"></a> 1. 同步</h4><pre><code>它的实现与 ArrayList 类似，但是使用了 `synchronized` 进行同步。</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-扩容-2"><a class="markdownIt-Anchor" href="#2-扩容-2"></a> 2 . 扩容</h4><p>​Vector 的构造函数可以传入 <code>capacityIncrement</code> 参数，它的作用是在扩容时使容量 <code>capacity</code> 增长 <code>capacityIncrement</code>。如果这个参数的值小于等于 0，扩容时每次都令 <code>capacity</code> 为原来的两倍。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">    * capacity increment. 构造函数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   initialCapacity     数组的初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   capacityIncrement   扩容时使容量 `capacity` 增长 `capacityIncrement`</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">    *         is negative</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>​调用没有 <code>capacityIncrement</code> 的构造函数时，<code>capacityIncrement</code> 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-与arraylist的比较"><a class="markdownIt-Anchor" href="#3-与arraylist的比较"></a> 3. 与ArrayList的比较</h4><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li></ul><h4 id="4-替代方案"><a class="markdownIt-Anchor" href="#4-替代方案"></a> 4. 替代方案</h4><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList &#x3D; Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">       return (list instanceof RandomAccess ?</span><br><span class="line">               new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">               new SynchronizedList&lt;&gt;(list));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) &#123;</span><br><span class="line">       return (list instanceof RandomAccess ?</span><br><span class="line">               new SynchronizedRandomAccessList&lt;&gt;(list, mutex) :</span><br><span class="line">               new SynchronizedList&lt;&gt;(list, mutex));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>也可以使用 <code>concurrent</code> 并发包下的 <code>CopyOnWriteArrayList</code> 类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></div><hr><h3 id="三-copyonwritearraylist"><a class="markdownIt-Anchor" href="#三-copyonwritearraylist"></a> 三、 CopyOnWriteArrayList</h3><h4 id="1-读写分离"><a class="markdownIt-Anchor" href="#1-读写分离"></a> 1. 读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     * 添加一个元素： 写操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">// 复制数组</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements); <span class="comment">// 写操作结束之后需要把原始数组指向新的复制数组。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 去锁操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h4><p>​<code>CopyOnWriteArrayList</code> 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合<strong>读多写少</strong>的应用场景。</p><p>​但是 <code>CopyOnWriteArrayList</code> 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 <code>CopyOnWriteArrayList</code> 不适合内存敏感以及对实时性要求很高的场景。</p><hr><h3 id="四-collections-与-arrays"><a class="markdownIt-Anchor" href="#四-collections-与-arrays"></a> 四、 Collections 与 Arrays</h3><p>集合框架中的工具类中的方法都是静态的</p><p><strong>Collection中的常见方法：</strong></p><ol><li><p>对List进行二分查找： int binarySearch(list, key)</p><p>​ int binarySearch(list, key, Comparator)</p><p>​二分查找需要列表有序</p></li><li><p>对list集合进行排序</p><p>sort(list):  其实是使用list容器中对象的CompareTo方法</p><p>sort(list, comparator) //按照指定比较器进行排序</p></li><li><p>对集合取最大值或者最小值</p><p>​max（collection）   min（collection）</p></li><li><p>对集合进行反转</p><p>​reverse(list)</p></li><li><p>对比较方式强行逆转</p><p>​Comparator reverseOrder();</p><p>​Comparator reverseOrder(Comparator);</p></li><li><p>对list中的元素的位置进行替换</p><p>​swap(list, x, y);</p></li><li><p>对集合中的元素进行替换， 如果被替换的元素不存在， 那么原来的集合不变</p><p>​replaceAll(list, old, new);</p></li><li><p>将集合变成数组</p><p>​Collection.toArray()  【collection不是Collections工具类】</p></li></ol><p>Arrays： 用于对数组操作的工具类: Arrays.方法()</p><ol><li><p>二分查找， 需要数组有序</p><p>binarySearch(int [])</p></li><li><p>数组排序</p><p>sort(int [])</p></li><li><p>将数组变成字符串</p></li></ol><p>toString(int [])</p><ol start="4"><li><p>复制数组</p><p>​copyOf()</p></li><li><p>复制部分数组</p><p>copyOfRange()</p></li><li><p>比较两个数组是否相同</p><p>equals(int [], int [])</p></li><li><p><strong>将数组变成集合</strong>：<br>List  asList(T [])</p><p>这样可以通过结合的操作来操作数组中的元素，但是不可以死使用增删方法， add， remove，因为数组的长度固定，会出现UnsupportOperationException.</p><hr></li></ol><h3 id="五-linkedlist"><a class="markdownIt-Anchor" href="#五-linkedlist"></a> 五、 LinkedList</h3><h4 id="1-概览-2"><a class="markdownIt-Anchor" href="#1-概览-2"></a> 1. 概览</h4><p>​ 基于双向链表实现，使用 Node 存储链表节点信息。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>每个链表存储了first和last指针，用Node来保存链表节点信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581314794535.png" data-fancybox="group" data-caption="1581314794535" class="fancybox"><img alt="1581314794535" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581314794535.png" class="lazyload" title="1581314794535"></a><h4 id="2与arraylist的比较"><a class="markdownIt-Anchor" href="#2与arraylist的比较"></a> 2.与ArrayList的比较</h4><p>​<code>ArrayList</code> 基于动态数组实现，<code>LinkedList</code> 基于双向链表实现。<code>ArrayList</code> 和 <code>LinkedList</code> 的区别可以归结为数组和链表的区别：</p><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li><li>链表不支持随机访问，但插入删除只需要改变指针。</li></ul><hr><h3 id="六-hashmap"><a class="markdownIt-Anchor" href="#六-hashmap"></a> 六、 HashMap</h3><pre><code>为了便于理解，以下源码分析以 JDK 1.7 为主。 </code></pre><h4 id="1-存储结构"><a class="markdownIt-Anchor" href="#1-存储结构"></a> 1. 存储结构</h4><pre><code>内部包含了一个 `Entry` 类型的数组 `table`。`Entry` 存储着键值对。它包含了四个字段，从 `next` 字段我们可以看出 `Entry` 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。`HashMap` 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 `Entry`。 </code></pre><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581315156142.png" data-fancybox="group" data-caption="1581315156142" class="fancybox"><img alt="1581315156142" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581315156142.png" class="lazyload" title="1581315156142"></a><p>以下源码基于JDK1.7</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​HashMap中两个参数会影响他的性能：初始容量和装载因子。初始容量是指哈希表中桶的个数，即哈希表的大小； 装载因子是表示hash表中元素的填满的程度，装 载因子越大，填满的元素越多，好处是，空间利用率高了，但冲突的机会加大了；反之，加载因子越小，填满的元素越少，好处是冲突的机会减小了，但空间浪费多了。</p><p>​冲突的机会越大，则查找的成本越高。反之，查找的成本越小，查找时间就越小。 因此，必须在 &quot;冲突的机会&quot;与&quot;空间利用率&quot;之间寻找一种平衡与折衷，这种平衡与折衷本质上是数据结构中有名的**&quot;时-空&quot;矛盾**的平衡与折衷。</p><p>​HashMap默认的装载因子是0.75，最大容量是16，因此可以得出HashMap的默认容量是：0.75*16=12。</p><p>用户可以自定义最大容量和装载因子。</p><p>​HashMap 包含如下几个构造器：</p><ul><li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li><li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li><li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li></ul><h4 id="2-拉链法工作原理"><a class="markdownIt-Anchor" href="#2-拉链法工作原理"></a> 2. 拉链法工作原理</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure></div><ul><li><p>新建一个 HashMap，默认大小为 16；</p></li><li><p>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</p></li><li><p>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</p></li><li><p>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</p><p>​应该注意到链表的插入是以<strong>头插法</strong>方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。查找需要分成两步进行：</p></li><li><p>计算键值对所在的桶；</p></li><li><p>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p></li></ul><a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581331248644.png" data-fancybox="group" data-caption="1581331248644" class="fancybox"><img alt="1581331248644" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581331248644.png" class="lazyload" title="1581331248644"></a><p>​</p><h4 id="3-put操作"><a class="markdownIt-Anchor" href="#3-put操作"></a> 3. put操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​ 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value &#x3D; v;</span><br><span class="line">    next &#x3D; n;</span><br><span class="line">    key &#x3D; k;</span><br><span class="line">    hash &#x3D; h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="在jdk18中的put操作"><a class="markdownIt-Anchor" href="#在jdk18中的put操作"></a> <strong>在JDK1.8中的put操作：</strong></h5> <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/58e67eae921e4b431782c07444af824e_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/58e67eae921e4b431782c07444af824e_hd.png" class="lazyload" title="img"></a> <p>思路如下：</p><p>1.table[]是否为空</p><p>2.判断table[i]处是否插入过值</p><p>3.判断链表长度是否大于8，如果大于就转换为<strong>红黑二叉树</strong>，并插入树中</p><p>4.判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value</p><p>5.如果key不相同，就插入一个key，记录结构变化一次</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//判断table是否为空，如果是空的就创建一个table，并获取他的长度</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//如果计算出来的索引位置之前没有放过数据，就直接放入</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;  <span class="comment">//进入这里说明索引位置已经放入过数据了</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断put的数据和之前的数据是否重复</span></span><br><span class="line">             <span class="comment">//key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是否是红黑树，如果是红黑树就直接插入树中</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123; <span class="comment">//如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash); <span class="comment">// 转换为红黑树</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                    <span class="comment">// 判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key，因此只需要将value覆盖，并将oldValue返回即可</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 扩容</span></span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict); <span class="comment">// 这个是给LinkedHashMap用的，HashMap里也是个空实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 添加成功返回null</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><h5 id="get方法"><a class="markdownIt-Anchor" href="#get方法"></a> get方法</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h4 id="4-确定桶下标"><a class="markdownIt-Anchor" href="#4-确定桶下标"></a> 4. 确定桶下标</h4><p>很多操作都需要先确定一个键值对所在的桶下标。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure></div><h5 id="41-计算-hash-值17"><a class="markdownIt-Anchor" href="#41-计算-hash-值17"></a> 4.1  计算 hash 值（1.7）</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="42-取模"><a class="markdownIt-Anchor" href="#42-取模"></a> <strong>4.2  取模</strong></h5><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : <span class="number">00010000</span></span><br><span class="line">x<span class="number">-1</span> : <span class="number">00001111</span></span><br></pre></td></tr></table></figure></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : <span class="number">10110010</span></span><br><span class="line">x-<span class="number">1</span>     : <span class="number">00001111</span></span><br><span class="line">y&amp;(x-<span class="number">1</span>) : <span class="number">00000010</span></span><br></pre></td></tr></table></figure></div><p>这个性质和 y 对 x 取模效果是一样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y   : <span class="number">10110010</span></span><br><span class="line">x   : <span class="number">00010000</span></span><br><span class="line">y%x : <span class="number">00000010</span></span><br></pre></td></tr></table></figure></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="44-在jdk18中的hash方法"><a class="markdownIt-Anchor" href="#44-在jdk18中的hash方法"></a> 4.4 在JDK1.8中的hash方法</h5><pre><code>hash()方法其实顾名思义就是用来获取key的hash的一个hash值的,但是HashMap里的hash()方法似乎与一般的直接key.hashCode()不太一样，我们先看看它到底是什么样的神奇操作。 其源码如下: </code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;  </span><br><span class="line">    <span class="comment">// key是null就返回0，key不是null就先取hashCode（）然后与这个hashCode（）无符号右移进行亦或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// 将hashCode的值异或他的高16位获取到hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​这是因为找key的位置时，<code>(n - 1) &amp; hash</code>是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高</p><p>​为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。</p><p>​ 我们知道hashCode本身是一个32位的int类型，进行这样的操作就等于将hashCode的高16位异或它的低16位得到一个新的hash值。</p> <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8e8203c1b51be6446cda4026eaaccf19_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8e8203c1b51be6446cda4026eaaccf19_hd.png" class="lazyload" title="img"></a>  <pre><code> 但是拿到这样一个hash值的作用是什么呢？我们可以先想一下如何利用key的hash值确定每个key的哈希桶索引位置而且还需要尽量均衡。第一个想到的当然是用hash值对哈希桶的长度(length)进行取模的操作。即:  **index = hash % length** </code></pre><p>​ 这种方式可以用随机的hash值算出随机的索引并且分配也尽量均匀。没错！!HashMap也是这么想的。但是这种取模运算本身是对CPU运算开销比较大的，为了优化速度，HashMap采取了更优雅的方式，在putVal的核心代码可以看到HashMap采用了hash值&quot;与&quot;length-1的方式来确定索引位置。即：</p><p>​<strong>index = hash &amp; length-1</strong></p><p>​hash()方法中的高16位异或16位的计算方式，是在JDK1.8之后才加上的，在JDK1.7及之前的版本里是indexFor()方法，直接用hashCode&amp;length-1计算出索引位置。这个是jdk1.7和jdk1.8中的区别。</p><h4 id="5-扩容-基本原理"><a class="markdownIt-Anchor" href="#5-扩容-基本原理"></a> 5. 扩容-基本原理</h4><p>​设 HashMap 的 table 长度为 <code>M</code>，需要存储的键值对数量为 <code>N</code>，如果哈希函数满足<strong>均匀性</strong>的要求，那么每条链表的长度大约为 <code>N/M</code>，因此查找的复杂度为 <code>O(N/M)</code>。</p><p>​为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>​和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><table><thead><tr><th>参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>capacity</td><td style="text-align:center">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td>size</td><td style="text-align:center">键值对数量。</td></tr><tr><td>threshold</td><td style="text-align:center">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td>loadFactor</td><td style="text-align:center">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;  <span class="comment">// 默认的初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//  最大容量  2 的 30次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  <span class="comment">// 默认的装载因子为0.75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// size就是HashMap中键值对的总个数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;  <span class="comment">// size 的临界值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 记录是发生内部结构变化的次数， fail-fast需要用</span></span><br><span class="line"> <span class="comment">// 如果put值，但是put的值是覆盖原有的值，这样是不算内部结构变化的。</span></span><br></pre></td></tr></table></figure></div><p>​ <code>threshold=装载因子 * capacity</code>  ，也就是说数组长度固定以后， 如果负载因子越大，所能容纳的元素个数越多，如果超过这个值就会进行扩容(默认是扩容为原来的2倍)，0.75这个值是权衡过空间和时间得出的，建议大家不要随意修改，如果在一些特殊情况下，比如空间比较多，但要求速度比较快，这时候就可以把扩容因子调小以较少hash冲突的概率。相反就增大扩容因子(这个值可以大于1)。</p><p>​ 因为HashMap扩容每次都是扩容为原来的2倍，所以<code>capacity</code> 总是2的次方，这是非常规的设置，<strong>常规设置是把桶的大小设置为素数，因为素数发生hash冲突的概率要小于合数</strong>，比如HashTable的默认值设置为11，就是桶的大小为素数的应用(HashTable扩容后不能保证是素数)。HashMap采用这种设置是为了在取模和扩容的时候做出优化。</p><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);  <span class="comment">// 两倍扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 <code>newTable</code> 中，因此这一步是很费时的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;<span class="comment">// 传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;  <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);  <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable; <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); <span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table; <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j]; <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>; <span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next; <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><pre><code>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 </code></pre> <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/e5aa99e811d1814e010afa7779b759d4_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/e5aa99e811d1814e010afa7779b759d4_hd.png" class="lazyload" title="img"></a> <pre><code>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</code></pre>  <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/a285d9b2da279a18b052fe5eed69afe9_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/a285d9b2da279a18b052fe5eed69afe9_hd.png" class="lazyload" title="img"></a> <pre><code>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </code></pre> <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/b2cb057773e3d67976c535d6ef547d51_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/b2cb057773e3d67976c535d6ef547d51_hd.png" class="lazyload" title="img"></a> <p>​因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p> <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/544caeb82a329fa49cc99842818ed1ba_hd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" style="zoom:80%;" align="center" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/544caeb82a329fa49cc99842818ed1ba_hd.png" class="lazyload" title="img"></a> <pre><code>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: </code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h4 id="6-扩容-重新计算桶下标"><a class="markdownIt-Anchor" href="#6-扩容-重新计算桶下标"></a> 6. 扩容-重新计算桶下标</h4><p>​在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap <code>capacity</code> 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p><p>​假设原数组长度 <code>capacity</code> 为 16，扩容之后 <code>new capacity</code> 为 32：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : <span class="number">00010000</span></span><br><span class="line"><span class="keyword">new</span> capacity : <span class="number">00100000</span></span><br></pre></td></tr></table></figure></div><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 <code>hash%00010000 = hash%00100000</code>，桶位置和原来一致；</li><li>为 1，<code>hash%00010000 = hash%00100000 + 16</code>，桶位置是原位置 + 16。</li></ul><h4 id="7-计算数组容量"><a class="markdownIt-Anchor" href="#7-计算数组容量"></a> 7. 计算数组容量</h4><p>​这里先了解一下基本的位运算</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">计算方式</th></tr></thead><tbody><tr><td style="text-align:center">与 &amp;</td><td style="text-align:center">只有两个数同一位都是1才会返回1</td></tr><tr><td style="text-align:center">或 l</td><td style="text-align:center">两个数同一位只要存在一个1就是1</td></tr><tr><td style="text-align:center">异或 ^</td><td style="text-align:center">两个数同一位不能相同才为1</td></tr><tr><td style="text-align:center">左移 &lt;&lt;</td><td style="text-align:center">所有位置左移，低位补0</td></tr><tr><td style="text-align:center">右移 &gt;&gt;</td><td style="text-align:center">正数：所有位置右移，高位补0 负数：写出补码（符号位不变，其余位置取反，然后加1），所有位置右移高位补1，然后再获取原码（符号位不变，其余位置取反，然后加1）</td></tr><tr><td style="text-align:center">无符号右移 &gt;&gt;</td><td style="text-align:center">无论正负高位补0</td></tr></tbody></table><p>​HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 用num与num左移的数字做或运算赋给num 。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>    <span class="number">11011000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>    <span class="number">11111110</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>    <span class="number">11111111</span></span><br></pre></td></tr></table></figure></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num     <span class="number">10010000</span></span><br><span class="line">mask+<span class="number">1</span> <span class="number">100000000</span></span><br></pre></td></tr></table></figure></div><p>以下是 HashMap 中计算数组容量的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="8-链表转红黑树"><a class="markdownIt-Anchor" href="#8-链表转红黑树"></a> 8. 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>  <a href="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8db4a3bdfb238da1a1c4431d2b6e075c_r.jpg" data-fancybox="group" data-caption="preview" class="fancybox"><img alt="preview" style="zoom:80%;" data-src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8db4a3bdfb238da1a1c4431d2b6e075c_r.jpg" class="lazyload" title="preview"></a>  <hr><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ol><li><p><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p></li><li><p><a href="https://www.cnblogs.com/cdream-zs/p/9997861.html" target="_blank" rel="noopener">超详细的HashMap解析(jdk1.8)</a></p></li><li><p><a href="https://www.cnblogs.com/duodushuduokanbao/p/9492952.html" target="_blank" rel="noopener">HashMap JDK1.8实现原理</a></p></li><li><p><a href="https://blog.csdn.net/zymx14/article/details/78394464" target="_blank" rel="noopener">java中的fail-fast(快速失败)机制</a></p></li><li><p><a href="https://www.cnblogs.com/songanwei/p/9387745.html" target="_blank" rel="noopener">面试题思考：java中快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://Castile.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://Castile.github.io/tags/Java/"/>
    
      <category term="Java基础" scheme="https://Castile.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-399-除法求值</title>
    <link href="https://castile.github.io/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>https://castile.github.io/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2020-01-31T14:30:10.000Z</published>
    <updated>2020-01-31T15:25:59.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p><p>示例 :<br>给定 a / b = 2.0, b / c = 3.0<br>问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</p><p>输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector<double>类型。</double></double></p><p>基于上述例子，输入如下：</p><p>equations(方程式) = [ [“a”, “b”], [“b”, “c”] ],<br>values(方程式结果) = [2.0, 3.0],<br>queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].<br>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-division" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-division</a></p></blockquote><p>此题难度为中等，但是我做了一天…， 太菜了。。。对于我来说还是比较复杂的题目了。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>dfs：使用深度优先搜索就比较直观。每个字母相当于一个节点，在给定的equations中建立合适的数据结构，建图，要求方程式的结果相当于求两个节点之间是否可以到达，可以到达则求出其代价，不能到达就设为-1.0.</p><p>我觉得此题的关键就是建图。</p><a href="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483374980.png" data-fancybox="group" data-caption="1580483374980" class="fancybox"><img alt="1580483374980" style="zoom:80%;" data-src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483374980.png" class="lazyload" title="1580483374980"></a><p>a/c = (a/b) * (b/c)，所以我们可以用<strong>图</strong>来解决 。</p></li><li><p>并查集： 比较特殊，在路径压缩那块比较复杂。。。以后补上吧</p><p><a href="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483517613.png" data-fancybox="group" data-caption="1580483517613" class="fancybox"><img alt="1580483517613" data-src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483517613.png" class="lazyload" title="1580483517613"></a></p></li></ol><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>Leetcode AC 代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 使用map的数据结构更好</span></span><br><span class="line">        <span class="comment">// 表示 a-&gt;b 的权重 即 a / b 的值</span></span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        buildGraph(g, equations, values);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String a = q.get(<span class="number">0</span>);</span><br><span class="line">            String b = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(a) || !g.containsKey(b))&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dfs(g, a, b, res, <span class="keyword">new</span> HashSet&lt;&gt;(), index, <span class="number">1.0</span>);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建图</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; e: equations)&#123;</span><br><span class="line">            String a = e.get(<span class="number">0</span>);</span><br><span class="line">            String b = e.get(<span class="number">1</span>);</span><br><span class="line">            g.putIfAbsent(a, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.putIfAbsent(b, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.get(a).put(b, values[index]);   <span class="comment">// a / b</span></span><br><span class="line">            g.get(b).put(a, <span class="number">1.0</span> / values[index]); <span class="comment">//  b / a</span></span><br><span class="line">            index++;</span><br><span class="line">            g.get(a).put(a, <span class="number">1.0</span>);</span><br><span class="line">            g.get(b).put(b, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, <span class="keyword">double</span>[] res, Set&lt;String&gt; visited, <span class="keyword">int</span> index,  <span class="keyword">double</span>  tmp)</span>       </span>&#123;</span><br><span class="line">        visited.add(a);</span><br><span class="line">        <span class="keyword">if</span>(g.get(a) == <span class="keyword">null</span> || g.get(a).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明a没有与其他点相连</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.get(a).containsKey(b))&#123;  <span class="comment">//  刚好有a-&gt;b的路径</span></span><br><span class="line">            res[index] = g.get(a).get(b) * tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(next))  <span class="keyword">continue</span>;</span><br><span class="line">            dfs(g, next, b, res, visited, index, g.get(a).get(next)*tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483055463.png" data-fancybox="group" data-caption="1580483055463" class="fancybox"><img alt="1580483055463" style="zoom:80%;" data-src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483055463.png" class="lazyload" title="1580483055463"></a><p>还有一些问题未解决，比如下面是自己写的代码，在idea上运行没毛病，但是在leetcode上就出错了。具体原因不详，欢迎大家提出问题进行交流，不胜感激！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_DFS</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt;  g = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 图</span></span><br><span class="line">        bulidGraph(g, equations, values);</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()]; <span class="comment">//   结果集合</span></span><br><span class="line"></span><br><span class="line">        Arrays.fill(res, -<span class="number">1.0</span>); <span class="comment">// 全部设置成-1.0；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历问题式子</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String a = q.get(<span class="number">0</span>);</span><br><span class="line">            String b = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(a) || !g.containsKey(b))&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(g, a, b, res, index, <span class="keyword">new</span> HashSet&lt;&gt;(), <span class="number">1.0</span>);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法在leetcode行不通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation_dfs(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bulidGraph(g, equations, values);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String x = q.get(<span class="number">0</span>);</span><br><span class="line">            String y = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(x) || !g.containsKey(y))&#123;</span><br><span class="line">                ans[index] = -<span class="number">1.0</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            ans[index] = divide(x, y, g, visited);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a / b</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">divide</span><span class="params">(String a, String b, Map&lt;String, Map&lt;String, Double&gt;&gt; g, Set&lt;String&gt; visitied)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( a == b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visitied.add(a);</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visitied.contains(next)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> d = divide(next, b, g, visitied); <span class="comment">//  d = next / b</span></span><br><span class="line">            <span class="comment">//  a /b =  next /b * a / next</span></span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> d * g.get(a).get(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, <span class="keyword">double</span>[] res, <span class="keyword">int</span> index, Set&lt;String&gt; visited, <span class="keyword">double</span> tmp)</span></span>&#123;</span><br><span class="line">        visited.add(a);</span><br><span class="line">        <span class="keyword">if</span>(g.get(a) == <span class="keyword">null</span> || g.get(a).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.get(a).containsKey(b)) &#123;</span><br><span class="line">            <span class="comment">//  刚好存在 a-&gt;b</span></span><br><span class="line">            res[index] = g.get(a).get(b) * tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(next))  <span class="keyword">continue</span>;</span><br><span class="line">            dfs(g, next, b, res, index, visited, g.get(a).get(next) * tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bulidGraph</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt;  g , List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; e: equations)&#123;</span><br><span class="line">            String a = e.get(<span class="number">0</span>);</span><br><span class="line">            String b = e.get(<span class="number">1</span>);</span><br><span class="line">            g.putIfAbsent(a, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.putIfAbsent(b, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.get(a).put(b, values[index]);   <span class="comment">//  a -&gt; b  : a / b</span></span><br><span class="line">            g.get(b).put(a, <span class="number">1.0</span> / values[index]); <span class="comment">//  b -&gt; a : b / a;</span></span><br><span class="line">            index++;</span><br><span class="line">            g.get(a).put(a, <span class="number">1.0</span>);</span><br><span class="line">            g.get(b).put(b, <span class="number">1.0</span>);  <span class="comment">//  自己到自己的权重为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="搜索" scheme="https://Castile.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-547-朋友圈</title>
    <link href="https://castile.github.io/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/"/>
    <id>https://castile.github.io/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/</id>
    <published>2020-01-30T06:15:07.000Z</published>
    <updated>2020-01-31T15:21:15.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>Leetcode547：Friend_Circles 朋友圈</p><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是<strong>传递性</strong>。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:</p><p>输入:<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>输出: 2<br>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回2。<br>示例 2:</p><p>输入:<br>[[1,1,0],<br>[1,1,1],<br>[0,1,1]]<br>输出: 1<br>说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>注意：</p><p>N 在[1,200]的范围内。<br>对于所有学生，有M[i][i] = 1。<br>如果有M[i][j] = 1，则有M[j][i] = 1。</p><p>链接：<a href="https://leetcode-cn.com/problems/friend-circles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/friend-circles</a></p><p>并查集、dfs、bfs</p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>并查集：转化为求连通个数。 好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，</p><p>那么 M[0][1]和 M[1][0]的值都为 1。 很简单直观。</p><p>并查集：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并查集 UF</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// n个元素</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        size = <span class="keyword">new</span>  <span class="keyword">int</span>[n];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 一开始每一个节点自成一个集合，都不连通</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n;  i++)&#123;</span><br><span class="line">            parent[i]  = i; <span class="comment">// 自己的父节点指向自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>; <span class="comment">// 每隔几何只有自身一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parent[x];</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x)&#123; <span class="comment">// 路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a);</span><br><span class="line">        <span class="keyword">int</span> rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == rootB)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 同一个集合不能合并</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size[rootA] &gt; size[rootB])&#123;</span><br><span class="line">                parent[rootB] = rootA;</span><br><span class="line">                size[rootA] += size[rootB];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootA] = rootB;</span><br><span class="line">                size[rootB] += size[rootA];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 连通分量个数减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>dfs：  给定的矩阵可以看成图的邻接矩阵。这样我们的问题可以变成无向图连通块的个数。</p><blockquote><p>M=</p><p>[1 1 0 0 0 0<br>1 1 0 0 0 0</p></blockquote></li></ol><blockquote><p>0 0 1 1 1 0<br>0 0 1 1 0 0<br>0 0 1 0 1 0<br>0 0 0 0 0 1]</p></blockquote><p>​ 如果我们把 M 看成图的邻接矩阵，则图为：</p><a href="/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/1580390918176.png" data-fancybox="group" data-caption="连通分量" class="fancybox"><img alt="连通分量" style="zoom:80%;" data-src="/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/1580390918176.png" class="lazyload" title="连通分量"></a><p>​ 在这个图中，点的编号表示矩阵 M 的下标，i 和 j之间有一条边当且仅当M[i][j]为 1。</p><p>​为了找到连通块的个数，一个简单的方法就是使用深度优先搜索，从每个节点开始，我们使用一个大小为 N 的 visited数组（M大小为 N×N ），这样 visited[i] 表示第 i 个元素是否被深度优先搜索访问过。每使用一次深度优先搜索，即重新选择了一个点进行dfs，连通分量的个数就加一。</p><ol start="3"><li>bfs:  方法与dfs类似，只是遍历方式是层次遍历， 使用的数据结构是队列。在广度优先搜索中，我们从一个特定点开始，访问所有邻接的节点。然后对于这些邻接节点，我们依然通过访问邻接节点的方式，知道访问所有可以到达的节点。因此，我们按照一层一层的方式访问节点。</li></ol><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-29 20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode547_FriendCircles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123; <span class="comment">// 是连通的并且还未访问</span></span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(M, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum_DFS</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(M, visited, i);</span><br><span class="line">                count++;  <span class="comment">// 执行一次dfs表示增加了一个连通块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面使用并查集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> []parents;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> []size;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">//  连通分量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">         size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">         count1 = n;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n; i++)&#123;</span><br><span class="line">             size[i] = <span class="number">1</span>;</span><br><span class="line">             parents[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> root = parents[a];</span><br><span class="line">         <span class="keyword">while</span>(root!= parents[root])&#123;</span><br><span class="line">             root = parents[root];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> roota = find(a);</span><br><span class="line">         <span class="keyword">int</span> rootb = find(b);</span><br><span class="line">         <span class="keyword">if</span>(roota != rootb)&#123;</span><br><span class="line">             <span class="keyword">if</span>(size[roota] &gt; size[rootb])&#123;</span><br><span class="line">                 parents[rootb] = roota;</span><br><span class="line">                 size[roota] = size[roota]+size[rootb];</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 parents[roota] = rootb;</span><br><span class="line">                 size[rootb] = size[roota]+size[rootb];</span><br><span class="line">             &#125;</span><br><span class="line">             count1--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        makeSet(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i&lt; n; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)<span class="comment">// 朋友</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     union(i, j);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count1;  <span class="comment">// 返回连通分量的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum_BFS</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = queue.remove();</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[k][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">                            queue.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] M = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(findCircleNum_DFS(M));  <span class="comment">// 2</span></span><br><span class="line">        System.out.println(findCircleNum_BFS(M));<span class="comment">// 2</span></span><br><span class="line">        System.out.println(findCircleNum(M));<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注： 使用并查集速度最快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="搜索" scheme="https://Castile.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="bfs" scheme="https://Castile.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Java关键字</title>
    <link href="https://castile.github.io/2020/01/29/Java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://castile.github.io/2020/01/29/Java%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-01-29T02:19:02.000Z</published>
    <updated>2020-01-29T03:16:50.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="final"><a class="markdownIt-Anchor" href="#final"></a> final</h1><h2 id="1-数据"><a class="markdownIt-Anchor" href="#1-数据"></a> <strong>1. 数据</strong></h2><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><h2 id="2-方法"><a class="markdownIt-Anchor" href="#2-方法"></a> <strong>2. 方法</strong></h2><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，<strong>而是在子类中定义了一个新的方法。</strong></p><h2 id="3-类"><a class="markdownIt-Anchor" href="#3-类"></a> <strong>3. 类</strong></h2><p>声明类不允许被继承。</p><h1 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h1><h2 id="1-静态变量"><a class="markdownIt-Anchor" href="#1-静态变量"></a> <strong>1. 静态变量</strong></h2><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field 'x' cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="2-静态方法"><a class="markdownIt-Anchor" href="#2-静态方法"></a> <strong>2. 静态方法</strong></h2><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。 即静态域中不能访问非静态的，因为静态的变量是先于对象（或者非静态）出现。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field 'y' cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // 'A.this' cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="3-静态语句块"><a class="markdownIt-Anchor" href="#3-静态语句块"></a> <strong>3. 静态语句块</strong></h2><p>静态语句块在类初始化时运行一次。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果只输出一次“123”</span></span><br></pre></td></tr></table></figure></div><h2 id="4-静态内部类"><a class="markdownIt-Anchor" href="#4-静态内部类"></a> <strong>4. 静态内部类</strong></h2><h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3><blockquote><p>大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类）</p></blockquote><h3 id="内部类的作用"><a class="markdownIt-Anchor" href="#内部类的作用"></a> 内部类的作用</h3><blockquote><ul><li>更好的封装性</li><li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量</li><li>匿名内部类适合用于创建那些仅需要一次使用的类</li></ul></blockquote><p>使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，<strong>static关键字的作用是把类的成员变成类相关，而不是实例相关 。</strong></p><p>注意：</p><ol><li>非静态内部类中不允许定义静态成员<br>2. 外部类的静态成员不可以直接使用非静态内部类<br>3. 静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员</li></ol><ul><li>在建造者模式中有使用，具体可以参考<a href="https://blog.csdn.net/cd18333612683/article/details/79129503" target="_blank" rel="noopener">链接</a></li></ul><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p><h2 id="5-静态导包"><a class="markdownIt-Anchor" href="#5-静态导包"></a> <strong>5. 静态导包</strong></h2><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure></div><p>一般我们导入一个类都用 <code>import com…..ClassName;</code></p><p>而静态导入是这样：<code>import static com…..ClassName.*;</code>  这里的多了个static，还有就是类名ClassName后面多了个.* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。</p><p><strong><code>好处：</code></strong></p><p>这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…); 就可以将其写入一个静态方</p><p>法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-29 10:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keywords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="6-初始化顺序"><a class="markdownIt-Anchor" href="#6-初始化顺序"></a> <strong>6. 初始化顺序</strong></h2><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"静态语句块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String field = <span class="string">"实例变量"</span>;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"普通语句块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>最后才是构造函数的初始化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ol><li><p><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></p></li><li><p><a href="https://blog.csdn.net/cd18333612683/article/details/79129503" target="_blank" rel="noopener">https://blog.csdn.net/cd18333612683/article/details/79129503</a></p></li><li><p><a href="https://blog.csdn.net/u012338954/article/details/51010337" target="_blank" rel="noopener">https://blog.csdn.net/u012338954/article/details/51010337</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://Castile.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://Castile.github.io/tags/Java/"/>
    
      <category term="Java基础" scheme="https://Castile.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="关键字" scheme="https://Castile.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-990-等式方程的可满足性</title>
    <link href="https://castile.github.io/2020/01/28/leetcode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/"/>
    <id>https://castile.github.io/2020/01/28/leetcode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/</id>
    <published>2020-01-28T14:45:18.000Z</published>
    <updated>2020-01-28T14:56:47.405Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：“a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p><p>示例 1：</p><p>输入：[“a==b”,“b!=a”]<br>输出：false<br>解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。<br>示例 2：</p><p>输出：[“b<mark>a&quot;，     &quot;a</mark>b”]<br>输入：true<br>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。<br>示例 3：</p><p>输入：[“a<mark>b&quot;,&quot;b</mark>c”,“a==c”]<br>输出：true<br>示例 4：</p><p>输入：[“a<mark>b&quot;, “b!=c”,&quot;c</mark>a”]<br>输出：false<br>示例 5：</p><p>输入：[“c<mark>c&quot;, &quot;b</mark>d”, “x!=z”]<br>输出：true</p><p>链接：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/satisfiability-of-equality-equations</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>根据等式的传递性，可以想到使用并查集非常快速可以解决此题。动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 <code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。</p><p><strong>核心思想</strong>是，<strong>将</strong> <strong><code>equations</code></strong> <strong>中的算式根据</strong> <strong><code>==</code></strong> <strong>和</strong> <strong><code>!=</code></strong> <strong>分成两部分，先处理</strong> <strong><code>==</code></strong> <strong>算式，使得他们通过相等关系各自勾结成门派；然后处理</strong> <strong><code>!=</code></strong> <strong>算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 21:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode990_SatisfiabilityOfEqualityEquations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>); <span class="comment">// 26个字母</span></span><br><span class="line">        <span class="comment">// 所有等式连通</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'='</span>) &#123; <span class="comment">// 判断为等式</span></span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                uf.union(x - <span class="string">'a'</span>, y - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断不等式会不会破坏连通性</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'!'</span>) &#123; <span class="comment">// 判断为不等式</span></span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (uf.isSameSet(x - <span class="string">'a'</span>, y - <span class="string">'a'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] equations1 = &#123;<span class="string">"c==c"</span>, <span class="string">"b==d"</span>, <span class="string">"x!=z"</span>&#125;; </span><br><span class="line">        System.out.println(equationsPossible(equations1)); <span class="comment">// true</span></span><br><span class="line">        String[] equations2 = &#123;<span class="string">"a==b"</span>, <span class="string">"b==c"</span>, <span class="string">"a==c"</span>&#125;;</span><br><span class="line">        System.out.println(equationsPossible(equations2)); <span class="comment">// true</span></span><br><span class="line">        String[] equations3 = &#123;<span class="string">"b==a"</span>, <span class="string">"a!=b"</span>&#125;;</span><br><span class="line">        System.out.println(equationsPossible(equations3)); <span class="comment">// fasle</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>dfs，图的联通性，染色问题，这是leetcode官方题解：</p><p>​思路： 所有相互等于的变量能组成一个联通分量。举一个例子，如果 <code>a=b, b=c, c=d</code>，那么 <code>a, b, c, d</code> 就在同一个联通分量中，因为它们必须相等。</p></li></ol><p>​第一步，我们基于给定的等式，用深度优先遍历将每一个变量按照联通分量染色。</p><p>​将联通分量染色之后，我们分析形如 a != b 的不等式。如果两个分量有相同的颜色，那么它们一定相等，因此如果说它们不相等的话，就一定无法满足给定的方程组。返回false。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 21:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode990_SatisfiabilityOfEqualityEquations</span> </span>&#123;</span><br><span class="line">    <span class="comment">//连通 染色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equationsPossible_DFS</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[<span class="number">26</span>]; <span class="comment">// 26个字母</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等式进行连通</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'='</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                graph[x - <span class="string">'a'</span>].add(y - <span class="string">'a'</span>);</span><br><span class="line">                graph[y - <span class="string">'a'</span>].add(x - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 准备26种颜色</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span>) &#123; <span class="comment">// 第i个字母还没染色</span></span><br><span class="line">                t++; <span class="comment">// 增加一种颜色</span></span><br><span class="line">                Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">                s.push(i);</span><br><span class="line">                <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> node = s.pop();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nn : graph[node]) &#123;<span class="comment">// 取出与node连通的所有点， 即取出等式两边的字母</span></span><br><span class="line">                        <span class="keyword">if</span> (color[nn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            color[nn] = t; <span class="comment">// 连通的节点设置成相同的颜色</span></span><br><span class="line">                            s.push(nn); <span class="comment">//  将与之连通的节点进栈，实现等式传递性的功能</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查不等式的合法性</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">'!'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = eq.charAt(<span class="number">0</span>) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> y = eq.charAt(<span class="number">3</span>) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == y || color[x] != <span class="number">0</span> &amp;&amp; color[x] == color[y]) &#123; <span class="comment">// 字母相等，颜色相同的一定不满足不等关系</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] equations1 = &#123;<span class="string">"c==c"</span>, <span class="string">"b==d"</span>, <span class="string">"x!=z"</span>&#125;;</span><br><span class="line">       </span><br><span class="line">        String[] equations2 = &#123;<span class="string">"a==b"</span>, <span class="string">"b==c"</span>, <span class="string">"a==c"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        String[] equations3 = &#123;<span class="string">"b==a"</span>, <span class="string">"a!=b"</span>&#125;;</span><br><span class="line">     </span><br><span class="line">        System.out.println(equationsPossible_DFS(equations1)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(equationsPossible_DFS(equations2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(equationsPossible_DFS(equations3)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>复杂度分析</p><p>时间复杂度： O(N)，其中 N是方程组 equations 的数量。</p><p>空间复杂度： O(1），认为字母表的大小是 O(1) 的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Java的自动装箱和拆箱</title>
    <link href="https://castile.github.io/2020/01/28/Java%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>https://castile.github.io/2020/01/28/Java%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</id>
    <published>2020-01-28T03:57:55.000Z</published>
    <updated>2020-01-28T04:10:07.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="自动装箱拆箱"><a class="markdownIt-Anchor" href="#自动装箱拆箱"></a> 自动装箱/拆箱</h1><hr><blockquote><p>自动装箱：指开发人员可以把一个基本数据类型直接赋给对应的包装类。</p><p>自动拆箱：指开发人员可以把一个包装类对象直接赋给对应的基本数据类型。</p></blockquote><h2 id="基本数据类型包装类"><a class="markdownIt-Anchor" href="#基本数据类型包装类"></a> 基本数据类型包装类</h2><table><thead><tr><th>包装类</th><th>基本数据类型</th></tr></thead><tbody><tr><td>Byte</td><td>byte</td></tr><tr><td>Integer</td><td>int</td></tr><tr><td>Long</td><td>long</td></tr><tr><td>Boolean</td><td>boolean</td></tr><tr><td>Float</td><td>float</td></tr><tr><td>Double</td><td>double</td></tr><tr><td>Character</td><td>char</td></tr><tr><td>对象变基本数据类型:拆箱</td><td>基本数据类型包装为对象:装箱</td></tr></tbody></table><hr><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><p>Example：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"12"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转换成int类型数据。 可以把字符串转换成对应的数字</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line">System.out.println(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数字转换成字符串</span></span><br><span class="line">System.out.println(<span class="string">"把整数转换成对应 的字符串："</span>+Integer.toString(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">//把整数转换成对应的进制形式</span></span><br><span class="line">System.out.println(<span class="string">"10的二进制："</span>+ Integer.toBinaryString(<span class="number">10</span>));</span><br><span class="line">System.out.println(<span class="string">"10的二进制："</span>+ Integer.toBinaryString(<span class="number">10</span>));</span><br><span class="line">System.out.println(<span class="string">"10的十六进制："</span>+ Integer.toHexString(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以把字符串当成对应的进行数据帮你转换</span></span><br><span class="line">String data = <span class="string">"10"</span>;</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(data, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"a="</span>+a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//集合： 集合是可以存储任意对象类型数据的容器。</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱： 自动把java的基本数据类型数据转换成对象类型数据。</span></span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span>;  <span class="comment">//基本数据类型</span></span><br><span class="line">Integer b =temp; <span class="comment">//把a存储的值赋予给b变量。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱： 把引用类型的数据转换成基本类型的数据</span></span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">13</span>);</span><br><span class="line"><span class="keyword">int</span> d = c; <span class="comment">//</span></span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用的数据类型</span></span><br><span class="line">Integer e = <span class="number">127</span>;</span><br><span class="line">Integer f = <span class="number">127</span>; </span><br><span class="line">System.out.println(<span class="string">"同一个对象吗？"</span>+(e==f)); <span class="comment">// ture</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意：</p><blockquote><p>Integer类内部维护 了缓冲数组，该缓冲数组存储的-128~127<br>这些数据在一个数组中。如果你获取的数据是落入到这个范围之内的，那么就直接从该缓冲区中获取对应的数据。【Java8】</p></blockquote><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">integer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">111</span>);</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">111</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>结果： false   true</p><blockquote><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul></blockquote><p>看下面的例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">integer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">160</span>);</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">160</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">160</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>结果为： false  false</p><p>因为160超过了缓存的范围（-128-127），所以都是不同的对象， valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 如果不在缓存池中，则会new一个Integer对象。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p><strong>看源码：</strong></p><hr><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​ 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</size></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>[<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java 基础</a>](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 基础)</li><li><a href="https://blog.csdn.net/Castile_zhu/article/details/78822267" target="_blank" rel="noopener">https://blog.csdn.net/Castile_zhu/article/details/78822267</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://Castile.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://Castile.github.io/tags/Java/"/>
    
      <category term="java基础" scheme="https://Castile.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-684-冗余连接</title>
    <link href="https://castile.github.io/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <id>https://castile.github.io/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</id>
    <published>2020-01-27T03:17:36.000Z</published>
    <updated>2020-01-27T03:24:39.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>Leetcode684:RedundantConnection 冗余连接①：</p><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>1<br>/ <br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>|   |<br>4 - 3<br>注意:</p><p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>并查集的应用：</p><a href="/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/1580095232083.png" data-fancybox="group" data-caption="时间复杂度分析" class="fancybox"><img alt="时间复杂度分析" style="zoom:80%;" align="center" data-src="/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/1580095232083.png" class="lazyload" title="时间复杂度分析"></a><p>直接看代码，一次AC</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-27 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Leetcode684:RedundantConnection 冗余连接①</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode684_RedundantConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = edges.length;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!uf.isSameSet(edge[<span class="number">0</span>], edge[<span class="number">1</span>]))&#123;</span><br><span class="line">                uf.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][]edges = &#123;&#123; <span class="number">1</span>,<span class="number">2</span> &#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123; <span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> []res = findRedundantConnection(edges);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-130-被围绕的区域</title>
    <link href="https://castile.github.io/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>https://castile.github.io/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-01-26T08:20:36.000Z</published>
    <updated>2020-01-26T13:02:02.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>Leetcode-130： 被围绕的区域</p><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：</p><p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>解释:</p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p>链接：<a href="https://leetcode-cn.com/problems/surrounded-regions" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>dfs搜索：将边界上的‘O’及其连通的先设置成‘#’标识，这些是不会被填充的，等搜索完毕之后再将这些标志换回‘O’。而在里面的‘O’就是被包围的区域，通过双层循环将里面的’O‘替换成’X‘即可。</p></li><li><p>并查集：并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。</p><p>并查集代码：UF</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-25 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 并查集 UF</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// n个元素</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        size = <span class="keyword">new</span>  <span class="keyword">int</span>[n];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 一开始每一个节点自成一个集合，都不连通</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n;  i++)&#123;</span><br><span class="line">            parent[i]  = i; <span class="comment">// 自己的父节点指向自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>; <span class="comment">// 每隔几何只有自身一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parent[x];</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x)&#123; <span class="comment">// 路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a);</span><br><span class="line">        <span class="keyword">int</span> rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == rootB)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 同一个集合不能合并</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size[rootA] &gt; size[rootB])&#123;</span><br><span class="line">                parent[rootB] = rootA;</span><br><span class="line">                size[rootA] += size[rootB];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootA] = rootB;</span><br><span class="line">                size[rootB] += size[rootA];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 连通分量个数减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>可以把那些不需要被替换的</strong> <strong><code>O</code></strong> <strong>看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫</strong> <strong><code>dummy</code>****，这些</strong> <strong><code>O</code></strong> <strong>和</strong> <strong><code>dummy</code></strong> <strong>互相连通，而那些需要被替换的</strong> <strong><code>O</code></strong> <strong>与</strong> <strong><code>dummy</code></strong> <strong>不连通</strong>。 如下图:</p><a href="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027256551.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img style="zoom:80%;" data-src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027256551.png" class="lazyload"></a><p>​首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p><p>​这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p><p>​其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p><p>​我们的思路是把所有边界上的 O看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类</p><ol><li>和边界上的 O在一个连通区域内的。这些 O 我们保留。</li><li>不和边界上的O 在一个连通区域内的。这些 O 就是被包围的，替换。</li></ol></li></ol><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><ol><li><p>dfs版本</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//  边缘搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i == <span class="number">0</span> || j == <span class="number">0</span> || i == m-<span class="number">1</span> || j == n-<span class="number">1</span>)  &amp;&amp;  (board[i][j] == <span class="string">'O'</span>))&#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                   board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>)&#123;</span><br><span class="line">                   board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i,  <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">'O'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] d: directions)&#123;</span><br><span class="line">            dfs(board, i+d[<span class="number">0</span>], d[<span class="number">1</span>]+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027995406.png" data-fancybox="group" data-caption="leetcode测试用例" class="fancybox"><img alt="leetcode测试用例" style="zoom:80%;" align="center" data-src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027995406.png" class="lazyload" title="leetcode测试用例"></a></li><li><p>并查集</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用并查集解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solveUF</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 边界上的‘O’的根节点都是dummy</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n * m + <span class="number">1</span>);<span class="comment">//  增加一个存储dummy节点</span></span><br><span class="line">    <span class="keyword">int</span> dummy = m * n;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123; <span class="comment">// 目标</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == m -<span class="number">1</span> || j == n -<span class="number">1</span>) &#123; <span class="comment">// 如果是边界上的'O'， 与dummy合并</span></span><br><span class="line">                    uf.union(i*n+j, dummy);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 里面的</span></span><br><span class="line">                    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">                    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">                    <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(x * n + y, i * n + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">1</span>;  i &lt; m-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!uf.isSameSet(i*n+j, dummy))&#123;</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580043663800.png" data-fancybox="group" data-caption="1580043663800" class="fancybox"><img alt="1580043663800" style="zoom:80%;" align="center" data-src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580043663800.png" class="lazyload" title="1580043663800"></a></li></ol><p>参考：</p><ol><li><a href="https://cyc2018.github.io/CS-Notes" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes</a></li><li><a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong#yi-dfs-de-ti-dai-fang-an" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong#yi-dfs-de-ti-dai-fang-an</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="https://Castile.github.io/tags/dfs/"/>
    
      <category term="并查集" scheme="https://Castile.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="搜索" scheme="https://Castile.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="中等" scheme="https://Castile.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1-两数之和</title>
    <link href="https://castile.github.io/2020/01/23/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://castile.github.io/2020/01/23/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-01-23T13:54:23.000Z</published>
    <updated>2020-01-23T14:15:03.787Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><ul><li>[x] 你可以假设每种输入只会对应一个答案。但是，<strong>你不能重复利用这个数组中同样的元素</strong>。</li></ul><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li><p>暴力方法： 直接两层循环，时间复杂度较高：O(n<sup>2</sup>)</p></li><li><p>哈希方法：使用哈希表可以实现O(1)级别的存取。存储每个数对应的下标，复杂度O(n)</p><p>参考：</p><p>HashMap的时间复杂度O(1)的思考：</p><p>​原文链接：<a href="https://blog.csdn.net/donggua3694857/article/details/64127131" target="_blank" rel="noopener">https://blog.csdn.net/donggua3694857/article/details/64127131</a></p></li></ol><h2 id="java代码实现"><a class="markdownIt-Anchor" href="#java代码实现"></a> Java代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-23 21:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_1_twoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    a[<span class="number">0</span>] = i;</span><br><span class="line">                    a[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mymap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;  i++)&#123;</span><br><span class="line">            mymap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mymap.containsKey(t) &amp;&amp; mymap.get(t) != i )&#123;<span class="comment">// 注意后面这个条件，题目要求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,mymap.get(t)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] nums = &#123; <span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">       <span class="keyword">int</span> []result = twoSum1(nums, target);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; result.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(result[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考HashMap：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486169&amp;idx=2&amp;sn=9818c995d51a19cd4a40c2605bdcfa5d&amp;chksm=ebd74bd8dca0c2cefe86f54bcdd7f799ceda0a14deb72a4fcec7efa29fc3deffbc6e80d8a90f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575479594341&amp;sharer_shareid=2d7d0e474d11d42bad66b1f70e2c85ff&amp;key=688085f24308deb8e963b43a687ea8ed3be23533e2ae4e751f02a336bb46979d39e6c74e731daa5fc22d9e719338c7f0f98152a12a38beef1d0023e2939dd0eda93264a9d032b8cc555448c332453c25&amp;ascene=1&amp;uin=MjA3NDA5MzU4MQ==&amp;devicetype=Windows%2010&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=A5ZIZKTn0EuksyOXwEiV%2bEk=&amp;pass_ticket=Nb/JBXAYTcQup5FBKcfsQy6kFv5X2eJwQ333U4h1UYJmrnawwezuSj8nX18XzQ8s" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486169&amp;idx=2&amp;sn=9818c995d51a19cd4a40c2605bdcfa5d&amp;chksm=ebd74bd8dca0c2cefe86f54bcdd7f799ceda0a14deb72a4fcec7efa29fc3deffbc6e80d8a90f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575479594341&amp;sharer_shareid=2d7d0e474d11d42bad66b1f70e2c85ff&amp;key=688085f24308deb8e963b43a687ea8ed3be23533e2ae4e751f02a336bb46979d39e6c74e731daa5fc22d9e719338c7f0f98152a12a38beef1d0023e2939dd0eda93264a9d032b8cc555448c332453c25&amp;ascene=1&amp;uin=MjA3NDA5MzU4MQ==&amp;devicetype=Windows 10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=A5ZIZKTn0EuksyOXwEiV%2BEk=&amp;pass_ticket=Nb/JBXAYTcQup5FBKcfsQy6kFv5X2eJwQ333U4h1UYJmrnawwezuSj8nX18XzQ8s</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="数组" scheme="https://Castile.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="简单" scheme="https://Castile.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>记2020年1月22日</title>
    <link href="https://castile.github.io/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/"/>
    <id>https://castile.github.io/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/</id>
    <published>2020-01-22T12:37:27.000Z</published>
    <updated>2020-01-22T12:50:08.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>2020年1月22日， 回老家的第二天，去了趟外婆家，吃撑了。</p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/1.jpg" data-fancybox="group" data-caption="捉鱼" class="fancybox"><img alt="捉鱼" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/1.jpg" class="lazyload" title="捉鱼"></a></p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/3.jpg" data-fancybox="group" data-caption="hhhhhhhh" class="fancybox"><img alt="hhhhhhhh" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/3.jpg" class="lazyload" title="hhhhhhhh"></a></p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/2.jpg" data-fancybox="group" data-caption="这鱼的力气好大啊" class="fancybox"><img alt="这鱼的力气好大啊" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/2.jpg" class="lazyload" title="这鱼的力气好大啊"></a></p><p>​这鱼的力气真大，在我手中挣脱好几次了，费了九牛二虎之力才把他弄回家！！！</p><p>​最近不知为啥，一吃饭，附近的各种野猫和其他人家的小狗就过来了…挺可爱的</p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/4.jpg" data-fancybox="group" data-caption="野猫" class="fancybox"><img alt="野猫" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/4.jpg" class="lazyload" title="野猫"></a></p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/5.jpg" data-fancybox="group" data-caption="野猫" class="fancybox"><img alt="野猫" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/5.jpg" class="lazyload" title="野猫"></a></p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/6.jpg" data-fancybox="group" data-caption="小白" class="fancybox"><img alt="小白" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/6.jpg" class="lazyload" title="小白"></a></p><p><a href="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/7.jpg" data-fancybox="group" data-caption="小白" class="fancybox"><img alt="小白" data-src="/2020/01/22/%E8%AE%B02020%E5%B9%B41%E6%9C%8822%E6%97%A5/7.jpg" class="lazyload" title="小白"></a></p><p>最几天肺炎很严重啊！担心。</p><p>再见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://Castile.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://Castile.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="日记" scheme="https://Castile.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-128-最长连续序列</title>
    <link href="https://castile.github.io/2020/01/22/leetcode-128-LongestConsecutiveSequence/"/>
    <id>https://castile.github.io/2020/01/22/leetcode-128-LongestConsecutiveSequence/</id>
    <published>2020-01-22T10:15:19.000Z</published>
    <updated>2020-01-23T14:15:48.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2><blockquote><p>LeetCode128: 最长连续序列longest-consecutive-sequence</p><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 <mark><strong>O(n)</strong></mark>。 【困难】</p><p>示例:</p><p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><p>链接：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence</a></p></blockquote><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>​如果允许O(nlogn)的复杂度，那么可以先排序，可是本题要求O(n)。<br>由于序列里的元素是无序的，又要求O(n)，首先要想到用哈希表。<br>用一个哈希表存储所有出现过的元素，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记 录下最长的长度。</p><h2 id="java代码实现"><a class="markdownIt-Anchor" href="#java代码实现"></a> Java代码实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-22 18:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组，找出最长连续序列的长度。</span></span><br><span class="line"><span class="comment">要求算法的时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode128_LongestConsecutiveSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; myset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums)&#123;</span><br><span class="line">            myset.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; myset.contains(j); j++)&#123;</span><br><span class="line">                myset.remove(j);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; myset.contains(j); j--)&#123;</span><br><span class="line">                myset.remove(j);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []nums = &#123;<span class="number">100</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = longestConsecutive(nums);</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出4</p><p>时间复杂度为O(n) ， 空间复杂度O(n)</p><p>Leetcode官方：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]+<span class="number">1</span>) &#123;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">                    currentStreak = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(longestStreak, currentStreak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://Castile.github.io/categories/Algorithm/"/>
    
    
      <category term="数组" scheme="https://Castile.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="算法" scheme="https://Castile.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="https://Castile.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="困难" scheme="https://Castile.github.io/tags/%E5%9B%B0%E9%9A%BE/"/>
    
  </entry>
  
</feed>
